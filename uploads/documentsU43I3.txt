universidad tecnica federico santa maria

departamento de informatica

valparaiso - chile

incorporacion de experiencias practicas con

kernel reales en la ensenanza de sistemas

operativos

cristian sebastian fuentes garrido

memoria para optar al titulo de
ingeniero civil en informatica

profesor guia
profesor correferente : sr. horst von brand

: sr. javier canas

febrero 2016

universidad tecnica federico santa maria, departamento de informatica

2

agradecimientos

a mi familia

por todo el apoyo tango monetario como animico lo que me hizo estar y mantener
mis estudios en la v region, claramente sin esto no se puede lograr una meta como
esta, en especial a mis padres y a mis hermanos quienes se dieron el trabajo de
ayudarme a costa de sus intereses.

a mi pareja

lily, por todo el animo y apoyo que me diste dia a dia y por aguantar todos estos
viajes sin poder vernos de una forma continua, el carino que nos tenemos es un
sustento de vida.

a mis amigos

aca tengo a varios, en primer lugar a andrea quien me ha aguantado todos estos
anos y a pesar de todo continua esta amistad. a mis companeros de departamento
en especial a roberto por todas esas pizzas que servian como energia en esos dias
de estudio y no estudio. a maximiliano, alondra, alejandro sazo, alejandro diaz
y daniela por la amistado brindada en todo este periodo academico. y a todos mis
companeros con los cuales se compartio y se logro nalizar las asignaturas como
corresponde.

a mis profesores

a mi profesor guia javier canas, quien me llevo en buen camino para nalizar
esta memoria. a mi profesor correferente horst von brand por darse el tiempo de
encontrar cada detalle. y a cada uno de los profesores de cada asignatura dada por la
ensenanza que dejaron para convertirme en un profesional de esta universidad.

eres como un pez grande en un
estanque pequeno.
edward bloom - big sh (2003)

resumen ejecutivo

el trabajo consiste en la investigacion de metodos de aprendizaje utilizados para la
ensenanza de la construccion de un sistema operativo. se busca que el alumno pueda
tomar un kernel para poder modicar y aprender con la practica, con ello se evaluan diez
cursos distintos, se escoge uno de ellos segun ciertos discriminantes y se trabaja en la
modicacion de este para que este adaptado a la realidad del departamento de informatica
de la universidad tecnica federico santa maria.

el trabajo concluye con la elaboracion de experiencias practicas de caracter evolutivo
en el cual se toma el esqueleto de un kernel real, se construye uno mas robusto durante el
periodo que transcurre el curso y asi se aprende en la marcha.

palabras clave. xv6, mit, nucleo, sistemas operativos.

universidad tecnica federico santa maria, departamento de informatica

iii

abstract

the work consists in the investigation of learning methods used to teach the construction
of an operativing system. you have to look for the pupil can take a "kernel"to modify and
learn with practice, with this you can evaluate ten dieret groups, it is chosen one of them
according to certain things and you work in the modication of this group to be addapted to
the reality of the departamento de informatica of the universidad tecnica federico santa
maria.

the work ends with the summery of practice experiences of evolutive character in wich
you can take the squeleton of a real kernel, so you can build a stronger one during the
period that last the course so in that way you they learn.

universidad tecnica federico santa maria, departamento de informatica

iv

indice de contenidos

indice de contenidos

indice de contenidos

1. introduccion
1.1. objetivos

.

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.1.1. objetivo principal
. . . . . . . . . . . . . . . . . . . . . . . . .
1.1.2. objetivos especicos . . . . . . . . . . . . . . . . . . . . . . . .
1.2. estructura del documento . . . . . . . . . . . . . . . . . . . . . . . . .

.

.

2. estado del arte

2.1. cursos implementados en otras universidades

. . . . . . . . . . . . . .
2.1.1. curso de massachusetts institute of technology . . . . . . . . . .
2.1.2. curso de carnegie mellon university . . . . . . . . . . . . . . .
2.1.3. curso de standford university . . . . . . . . . . . . . . . . . . .
2.1.4. curso de harvard, school of engineering and applied sciences .
2.1.5. curso de university of illinois at chicago . . . . . . . . . . . . .
2.1.6. curso de university of california . . . . . . . . . . . . . . . . .
2.1.7. curso de university of florida . . . . . . . . . . . . . . . . . . .
2.2. sistemas operativos creados para el aprendizaje no utilizados en cursos .
2.2.1. crocos 0.2 . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.3. alternativas para el aprendizaje buscado . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .

2.3.1.
2.3.2. brans kernel development

jamesms kernel development tutorials

3. evaluacion de sistemas

3.1. cursos para comparar . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.1.1. curso de massachusetts institute of technology . . . . . . . . . .
3.1.2. curso de carnegie mellon university . . . . . . . . . . . . . . .
3.1.3. curso de standford university . . . . . . . . . . . . . . . . . . .
3.1.4. curso de harvard, school of engineering and applied sciences .
3.1.5. curso de university of illinois at chicago . . . . . . . . . . . . .
3.1.6. curso de university of california . . . . . . . . . . . . . . . . .
3.1.7. curso de university of florida . . . . . . . . . . . . . . . . . . .
3.1.8. crocos 0.2 . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.1.9.
. . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
3.1.10. brans kernel development
3.2. resumen, tablas comparativas . . . . . . . . . . . . . . . . . . . . . . .
3.2.1. comparacion con respecto a los contenidos ofrecidos . . . . . . .

jamesms kernel development tutorials

universidad tecnica federico santa maria, departamento de informatica

1
2
2
2
2

5
5
5
8
10
11
13
15
16
18
18
20
20
21

23
26
26
27
28
28
29
30
31
31
32
33
34
35

v

indice de contenidos

indice de contenidos

3.3. analisis de los datos

.

.

.

.

los cursos .

3.2.4. comparacion con respecto al tamano del kernel a modicar

3.2.2. comparacion con respecto a su disponibilidad y ultima actualizacion 36
3.2.3. comparacion con respecto a los tiempos necesarios para realizar
. . . . . . . . . . . . . . . . . . . . . . . . .
. . .
. . . . . . . . . . . . . . . . . . . . . . . . .
3.3.1. caracteristicas de su codigo . . . . . . . . . . . . . . . . . . . .
3.3.2. ultima actividad conocida . . . . . . . . . . . . . . . . . . . . .
3.3.3. existencia de libro guia . . . . . . . . . . . . . . . . . . . . . . .
3.3.4. experiencias aplicadas en sus cursos . . . . . . . . . . . . . . . .
3.3.5. conclusiones luego del analisis
. . . . . . . . . . . . . . . . . .

37
38
38
39
39
40
40
42

.

.

.

4. implementacion del curso

4.1. curso modicado para el departamento de informatica . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . .
.
.
. . . . . . . . . . . . . . . . . . . . . . . . .

4.1.1. objetivos .
.
.
4.1.2. contenidos .
.
4.1.3. evaluaciones .
4.1.4. programacion .

.
.
.
.

5. conclusiones

bibliografia

a. documentacion

43
44
44
44
45
46

47

49

53

53

.

.

.

.

.

.

.

tutorials .

of technology .

a.1. instalacion de sistema operativo xv6 para curso de massachusetts institute
. . . . . . . . . . . . . . . . . . . . . . . . .
a.2. instalacion de sistema operativo creado en jamesms kernel development
. . . . . . . . . . . . . . . . . . . . . . . . . .

54
a.3. instalacion de sistema operativo pintos para curso de standford university 55
a.4. instalacion de sistema operativo xinu para curso de university of florida
56
a.5. instalacion de sistema operativo cs 161 para el curso cs 161: operating
systems de harvard university . . . . . . . . . . . . . . . . . . . . . . .
a.6. instalacion de sistema operativo creado en bran kernel tutorial . . . . . .

59
60

.

.

.

.

.

.

.

b. desarrollo de curso ofrecido por mit

.

.

b.1. lab 1: booting a pc .

. . . . . . . . . . . . . . . . . . . . . . . . .
b.1.1. part 1: pc bootstrap . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . .
b.1.2. part 2: the boot loader
b.1.3. part 3: the kernel
. . . . . . . . . . . . . . . . . . . . . . . . .
b.2. lab 2: memory management . . . . . . . . . . . . . . . . . . . . . . . .
b.2.1. part 1: physical page management . . . . . . . . . . . . . . . . .
b.2.2. part 2: virtual memory . . . . . . . . . . . . . . . . . . . . . . .
b.2.3. part 3: kernel address space . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . .
b.3.1. part a: user environments and exception handling . . . . . . .
b.3.2. part b: page faults, breakpoints exceptions, and system calls . .
b.4. lab 4: preemptive multitasking . . . . . . . . . . . . . . . . . . . . . .

b.3. lab 3: user environments

universidad tecnica federico santa maria, departamento de informatica

63
63
64
66
68
70
71
74
79
80
81
87
92

vi

indice de contenidos

indice de contenidos

b.4.1. part a: multiprocessor support and cooperative multitasking . .
93
b.4.2. part b: copy-on-write fork . . . . . . . . . . . . . . . . . . . . 103
b.4.3. part c: preemptive multitasking and inter-process communication

.

.

(ipc)

b.5. lab 5: file system, spawn and shell

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
. . . . . . . . . . . . . . . . . . . . 114
b.5.1. the file system . . . . . . . . . . . . . . . . . . . . . . . . . . 115
b.5.2. spawning processes
. . . . . . . . . . . . . . . . . . . . . . . . 121
b.5.3. the keyboard interface . . . . . . . . . . . . . . . . . . . . . . . 125
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
b.5.4. the shell

universidad tecnica federico santa maria, departamento de informatica

vii

indice de contenidos

indice de contenidos

universidad tecnica federico santa maria, departamento de informatica

viii

indice de tablas

indice de tablas

indice de tablas

2.1. horas de dedicacion curso de massachusetts institute of technology . . .
2.2. ponderaciones curso xv6 de mit.
. . . . . . . . . . . . . . . . . . . . .
2.3. horas de dedicacion curso de carnegie mellon university . . . . . . . .
2.4. ponderaciones curso de carnegie mellon university . . . . . . . . . . . .
2.5. ponderaciones curso de standford university . . . . . . . . . . . . . . .
2.6. horas estimadas curso de standford university . . . . . . . . . . . . . .
2.7. horas estimadas curso de harvard, school of engineering and applied
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.8. ponderaciones curso de harvard . . . . . . . . . . . . . . . . . . . . . .
2.9. horas estimadas curso de university of illinois at chicago . . . . . . . .
2.10. ponderaciones curso de university of california . . . . . . . . . . . . . .
2.11. horas estimadas curso de university of california
. . . . . . . . . . . .
2.12. horas estimadas curso de university of florida . . . . . . . . . . . . . .
2.13. ponderaciones curso de university of florida . . . . . . . . . . . . . . .

sciences .

.

.

.

.

5
6
8
8
10
10

12
12
14
15
15
17
17

25

26

.

.

.

3.1. simbolos para representar participacion del alumno por cada tema. . . . .
3.2. tabla comparativa de temas abordados por el curso de massachusetts
institute of technology . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.3. tabla comparativa de temas abordados por el curso de carnegie mellon
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

university .

at chicago .

27
3.4. tabla comparativa de temas abordados por el curso de standford university 28
3.5. tabla comparativa de temas abordados por el curso de harvard, school of
engineering and applied sciences . . . . . . . . . . . . . . . . . . . . .
3.6. tabla comparativa de temas abordados por el curso de university of illinois
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

30
3.7. tabla comparativa de temas abordados por el curso de university of california 31
3.8. tabla comparativa de temas abordados por el curso de university of florida 32
3.9. tabla comparativa de temas abordados por el so crocos 0.2 . . . . . .
32
33
3.10. tabla comparativa de temas abordados por el tutorial de jamesm . . . .
34
3.11. tabla comparativa de temas abordados por el tutorial de bran . . . . . .
3.12. representacion de los cursos en siglas para las siguientes tablas.
. . . . .
34
35
3.13. tabla comparativa de temas abordados por todos los cursos. . . . . . . . .
36
. . . . . . . . . .
3.14. tabla comparativa de disponibilidad de contenidos (1).
3.15. tabla comparativa de disponibilidad de contenidos (2).
. . . . . . . . . .
36

29

.

.

.

universidad tecnica federico santa maria, departamento de informatica

ix

indice de tablas

indice de tablas

.

.

.

.

.

.

.

.

.

.

.

.

.

compilable .

universidades .

3.16. horas estimadas para todos los cursos investigados implementados en otras
. . . . . . . . . . . . . . . . . . . . . . . . .
3.17. tabla comparativa de tamanos de sistemas operativos de cursos con codigo
38
. . . . . . . . . . . . . . . . . . . . . . . . . .
39
3.18. extracto de tablas 3.14 y 3.15 con respecto a compilacion.
. . . . . . . .
40
3.19. extracto de tablas 3.14 y 3.15 con respecto a ultima actualizacion. . . . .
3.20. cursos considerados que cuentan con libro guia. . . . . . . . . . . . . . .
40
3.21. cursos considerados que cuentan con experiencias practicas pre-construidas. 41
42
3.22. resumen, discriminacion de cursos. . . . . . . . . . . . . . . . . . . . .

37

4.1. ponderaciones de curso propuesto.
4.2. schedule para 16 semanas de clases.

. . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .

b.1. tabla para ejercicio laboratorio 2 parte 2.

. . . . . . . . . . . . . . . . .

45
46

75

universidad tecnica federico santa maria, departamento de informatica

x

capitulo 1. introduccion

1 |

introduccion

actualmente en la carrera de ingenieria civil en informatica de nuestra universidad, en
el area de infraestructuras tic, mas especico en la asignatura de sistemas operativos, se
da un enfoque teorico sobre la construccion de un sistema operativo como tal[10]. es clara
la separacion entre lo teorico y practico donde los alumnos no alcanzan a experimentar que
es la modicacion y elaboracion de un sistema como este[9].

se busca lograr una asignatura para el departamento de informatica que solucione esta
brecha y que permita a los alumnos interesados ver el lado practico de la construccion de
un sistema operativo como tal, mas especico, experimentar con modulos de kernels.

el proposito del curso que se elaborara consiste en darle al alumno el conocimiento
necesario de como trabajan realmente los computadores a tal bajo nivel, dandole las
herramientas requeridas para que, con un lenguaje de alto nivel (como el lenguaje c)[19],
se consiga la creacion o modicacion de modulos de kernel, los cuales puedan experimentar
en un ambiente de prueba real.

el alumno experimentara los fundamentos de los engranajes de un sistema operativo, ta-
les como la memoria virtual, el modo usuario, llamadas de sistemas, threads, interrupciones,
comunicacion interprocesos, coordinacion, concurrencia y la interfaz presente el software y
el hardware lo cual es lo mas importante en general de todo este proceso. se busca que el
alumno aprecie todo lo que es el proceso de diseno y vea la importancia de la reduccion de
la complejidad y la integridad conceptual. para poder abarcarlos, es necesario analizar un
kernel de sistema operativo, el cual esta denido como la parte en donde se ejecutan todos
los comandos que estan en modo kernel y permite un acceso seguro al hardware mediante
llamadas al sistema[13]. tambien es el encargado de la gestion de recursos como el analisis
de los dispositivos de e/s[13].

universidad tecnica federico santa maria, departamento de informatica

1

1.1. objetivos

capitulo 1. introduccion

la investigacion se centrara en la busqueda de metodos de aprendizaje ya aplicados
en otras partes del mundo; esto engloba a instituciones educacionales, organizaciones sin
nes de lucro y tutoriales simples de internet. se evaluaran sus contenidos y metodos de
ensenanza para poder converger a uno o mas metodos que se vean factibles para el ambiente
del departamento de informatica.

1.1. objetivos

1.1.1. objetivo principal

proporcionar herramientas para unir teoria y practica en el aprendizaje de sistemas
operativos.

1.1.2. objetivos especicos

seleccionar uno o mas sistemas operativos utilizados para el proceso educativo.

elaborar un plan de ensenanza para el aprendizaje.

establecer topicos de caracter acumulativo para las distintas experiencias del taller.

1.2. estructura del documento

comenzamos con la situacion actual, en donde vemos como otras instituciones de
educacion han abordado este tema y cuales son algunos de los sistemas operativos que han
sido creados para el aprendizaje del diseno, todo esto en el capitulo 2. luego realizamos una
comparacion de todos estos cursos, mediante el metodo de evaluacion de incorporacion de
topicos relevantes para la construccion de un sistema operativo, los cursos son comparados
por igual y se discrimina segun criterios nombrados; esto lo encontramos en el capitulo 3.
las compilaciones logradas de los sistemas operativos se encuentran documentadas en el
anexo a. posterior a la evaluacion y como resultado de esta, tenemos el desarrollo del
curso escogido con la construccion de uno especial para el departamento de informatica,

universidad tecnica federico santa maria, departamento de informatica

2

1.2. estructura del documento

capitulo 1. introduccion

el desarrollo del curso lo encontramos en el anexo b y la construccion del curso se
encuentra en el capitulo 4. finalmente tenemos la conclusion del trabajo, la cual engloba
los resultados obtenidos luego de toda esta investigacion, lo que se encuentra en el capitulo 5.
las experiencias construidas para el curso se encuentran en el anexo digital.

universidad tecnica federico santa maria, departamento de informatica

3

1.2. estructura del documento

capitulo 1. introduccion

universidad tecnica federico santa maria, departamento de informatica

4

capitulo 2. estado del arte

2 | estado del arte

en este capitulo se investigara sobre la existencia de metodos de aprendizaje que se
han utilizado para poder interiorizarse en lo que es un sistema operativo a bajo nivel. se
encontraron diez metodos de los cuales dos de ellos son tutoriales de construccion de un
sistema operativo desde cero, uno es un kernel no compilado que esta construido por partes
para ir explicando su proceso, y siete cursos de distintas universidades con sus respectivos
objetivos y metodos de ensenanza.

2.1. cursos implementados en otras universidades

2.1.1. curso de massachusetts institute of technology

el curso 6.828 de massachusetts institute of technology (mit) esta orientado princi-
palmente al estudio de ideas sobre el diseno y la implementacion de un sistema operativo
basado en unix[22]. el curso es dictado por frans kaashoek, profesor del department of
electrical engineering and computer science, miembro del mit computer science and
articial intelligence laboratory y principal colaborador del libro xv6, a simple, unix-like
teaching operating system[29] junto a russ cox y robert morris.

el plan de estudio se centra en el sistema operativo xv6, el cual fue desarrollado en

semanas de duracion
horas/sesiones de clase por semana
horas/sesiones de taller por semana
horas estimadas de dedicacion adicional (semanas)
horas promedio dedicadas por taller

16 semanas
2 sesiones

-

4 horas
9 horas

tabla 2.1: horas de dedicacion curso de massachusetts institute of technology

universidad tecnica federico santa maria, departamento de informatica

5

2.1. cursos implementados en otras universidades

capitulo 2. estado del arte

verano de 2006 para este curso, siendo una modicacion del ya obsoleto unix v6[18] en
donde los estudiantes experimentaban con codigo de hace 30 anos atras. se moldeo de tal
forma que paso a ser multiplataforma y con soporte para multiprocesadores, de tal manera
que v6 fue reemplazado[24].

la evaluacion del curso consiste en la realizacion de dos pruebas; una a mediados
del semestre y otra en las ultimas semanas, cinco laboratorios de trabajo individual y dos
laboratorios de trabajo grupal. las ponderaciones de cada trabajo se adjuntan en la tabla 2.2.
los laboratorios estan construidos de tal forma que la experiencia sea incremental y el
codigo sea reutilizado para los siguientes laboratorios; se basan en la construccion de un
so con un kernel de tipo exokernel el cual esta principalmente escrito en lenguaje c. es
necesario tener nalizado el laboratorio 1 para proseguir con el 2, y asi sucesivamente[22].
los topicos abarcados por laboratorio son:

pruebas
labs 1 - 5

tareas, revisiones,

participacion

en clases

retos y proyecto nal

ponderacion

30 %
40 %

15 %

15 %

tabla 2.2: ponderaciones curso xv6 de mit.

lab 1 booting a pc la experiencia se separa en tres partes. la primera corresponde a un
acercamiento a las herramientas a utilizar durante todo el curso, tal como el emulador
qemu x86 para correr el sistema operativo, lenguaje assembly y el sistema de
booteo de un computador. la segunda parte corresponde al booteo desde el mismo
kernel. y la ultima corresponde a la construccion del template inicial para el kernel a
construir.

lab 2: memory manager el objetivo principal de la experiencia es escribir en codigo
el manejo de memoria del sistema operativo, realizando el trabajo tanto para la
memoria fisica y la memoria virtual. para la memoria fisica el trabajo consiste en
tener estructuras que guarden que espacios estan libres o no junto el lugar en donde se

universidad tecnica federico santa maria, departamento de informatica

6

2.1. cursos implementados en otras universidades

capitulo 2. estado del arte

encuentran localizadas y cuantos procesos comparten dicho espacio y cuales son. por
otro lado, para la memoria virtual se busca que se construyan las tablas de paginas
segun se estime conveniente para las siguientes experiencias.

lab 3 user environments se espera que al nalizar esta experiencia se tenga un sistema
protegido para utilizar el modo usuario y asi poder correr procesos sin inconvenientes.
como nalidad, el trabajo debe ser ejecutado junto a un proceso en el. se trabaja el
manejo de excepciones e interrupciones, errores de paginas y llamadas al sistema.

lab 4 preemptive multitasking se busca implementar multiples y simultaneos ambientes
de modo usuario. la experiencia se divide en tres partes, la primera corresponde a la
extension del kernel para el soporte de multiprocesos y nuevas llamadas al sistema
para que en modo usuario se puedan crear nuevos ambientes, implementar un sistema
cooperativo de tipo round-robin para la ejecucion de procesos y la implementacion
de un sistema interrumpible para que el kernel pueda volver a retomar el control de la
cpu luego de un tiempo determinado, incluso si el entorno no coopera. la segunda
parte consiste en la implementacion de fork() en modo usuario. en la tercera parte se
trabaja la construccion de la comunicacion entre procesos, de tal forma que distintos
modo usuarios se comuniquen y sincronicen entre si.

lab 5 file system, spawn and shell la experiencia se basa en la construccion de la bi-
blioteca spawn para permitir leer y escribir archivos en el disco duro. tambien dejar
preparado el sistema para poder correr una terminal por consola.

lab 6 network driver (default nal project) es un trabajo individual y corresponde a la
primera parte del proyecto nal. el objetivo es conectar el sistema operativo a la red;
para ello es necesario escribir un driver para la interfaz de red y hacer funcionar bajo
qemu transmitiendo paquetes.

lab 7 final jos project consiste en extender todo el trabajo realizado hasta el momento
a lo que el/los alumnos estimen conveniente. es un trabajo grupal como individual.

el curso completo, tanto los laboratorios como el codigo fuente, estan bajo la licencia

universidad tecnica federico santa maria, departamento de informatica

7

2.1. cursos implementados en otras universidades

capitulo 2. estado del arte

tradicional del mit[27] con lo cual es posible la utilizacion y adaptacion de toda su
informacion mientras se referencie su origen.

2.1.2. curso de carnegie mellon university

la universidad carnegie mellon en su departamento de computer science, implementa
el curso 15-410 llamado operating system design and implementation. el curso se basa en
la experiencia de escribir una pequena unidad de kernel de unix en lenguaje c y x86 intel
assembly[7].

semanas de duracion
horas/sesiones de clase por semana
horas/sesiones de taller por semana
horas estimadas de dedicacion adicional (semanas)
horas promedio dedicadas por taller

16 semanas
2 sesiones

-

3 horas
7,5 horas

tabla 2.3: horas de dedicacion curso de carnegie mellon university

el curso esta implementado para ser desarrollado en grupos de dos personas y se enfoca
directamente en la modicacion y creacion de modulos para un sistema operativo base.
dichos modulos se trabajan con el lenguaje de programacion c. el curso ofrece un sistema
operativo base con el sistema de booteo incluido[7].

proyecto 0
proyecto 1
proyecto 2
proyecto 3
proyecto 4

primer examen
segundo examen
tareas y reportes

ponderacion

5 %
5 %
15 %
25 %
5 %
15 %
20 %
10 %

tabla 2.4: ponderaciones curso de carnegie mellon university

durante el transcurso del curso se calican cinco proyectos grupales y dos examenes.
la informacion requerida para cada uno de los topicos es bastante densa la cual requiere de
mucha lectura. las ponderaciones estan en la tabla 2.4 y los topicos del proyecto son los
siguientes:

universidad tecnica federico santa maria, departamento de informatica

8

2.1. cursos implementados en otras universidades

capitulo 2. estado del arte

proyecto 0 traceback el objetivo es crear la libreria de traceback con la intencion de
poder leer memoria de un nivel determinado de una pila. la idea es obtener un
sistema que nos permita conocer un error cuando exista dicha excepcion. la creacion
de esta libreria permitiria conocer la informacion que dispone la tarea predenida
para este caso.

proyecto 1 nonogram consiste en la creacion de tres drivers fundamentales para la inter-
accion del usuario en el sistema operativo, la creacion de una consola de terminal
que permita imprimir caracteres por pantalla, crear el controlador para el teclado
para lograr capturar las teclas presionadas, y lo ultimo es el manejo del tiempo y su
captura para el uso en el sistema.

proyecto 2 hand-in la experiencia se basa en la construccion del sistema de reserva de
memoria de tipo mutex con variables de condicion, la creacion de la libreria de
thread y librerias extras de rutina como semaforos y r/w lock.

proyecto 3 introduction to the kernel project es la parte del proyecto en donde se re-
quiere la mayor cantidad de conocimientos. se busca crear el sistema de multitasking,
el manejo multiple de direcciones virtuales, un aumento notorio de las llamadas
a sistemas y un aumento en general del proyecto en si. pretende que los alumnos
analicen lo que pueden agregar al sistema.

proyecto 4 dma+cllfs se centra en la creacion del driver de un disco ide para dar la
posibilidad de usar interrupciones y tener acceso directo a la memoria, ademas de la
creacion completa de un sistema distinto de le system con tal de utilizar la llamada
a sistema readfile() y ser utilizada para otras nuevas llamadas necesarias para el
completo funcionamiento[7].

el curso esta bajo la licencia cmu[36] la que permite su uso, copia, modicacion y
distribucion mientras que se comente el origen de este. pero se debe tener en cuenta que en
dicho curso utilizan el simulador simics, el cual necesita de una licencia especial de wind
river (www.windriver.com) la que ofrecen de forma gratuita para propositos educativos
con previa solicitud.

universidad tecnica federico santa maria, departamento de informatica

9

2.1. cursos implementados en otras universidades

capitulo 2. estado del arte

2.1.3. curso de standford university

la universidad de standford imparte el curso cs 140: operating system dictado por el
profesor john ousterhout. el curso se basa en la modicacion de los modulos del sistema
operativo pintos[38] con tal de entender el funcionamiento en sus distintos componentes.
pintos es un framework de sistema operativo para arquitecturas 80x86, soporta threads,
carga de programas y le system, todos implementados en su forma mas simple posible. el
curso se centra en hacer pintos un sistema operativo mas robusto[37].

problemas
proyecto
prueba 1
prueba 2

ponderacion

5 %
50 %
15 %
30 %

tabla 2.5: ponderaciones curso de standford university

el curso se compone de dos pruebas, una a mediados del curso y otra al nalizar, cuenta
con problemas tipo desafio y el proyecto, el cual se separa en cuatro trabajos que se reparten
durante todo el semestre, puede tomar entre 10 a 20 horas semanales con la posibilidad de
ser realizado entre 2 a 3 personas[37].

semanas de duracion
horas/sesiones de clase por semana
horas/sesiones de taller por semana
horas estimadas de dedicacion adicional (semanas)
horas promedio dedicadas por taller

10 semanas
3 sesiones

algunas sesiones*

10-20 horas

25 horas

tabla 2.6: horas estimadas curso de standford university

los problemas de desafio son ejercicios de trabajo individual que deben ser desarrolla-
dos dentro de pintos y abordan el topico de sincronizacion. se debe programar en lenguaje
c dos funciones que utilizan funciones propias de pintos con tal de familiarizarse con las
bibliotecas que trae implementadas[37]. por otro lado, el proyecto consta de los siguientes
topicos segun numero de actividad a realizar:

proyecto 1 threads se les entrega a los alumnos un sistema minimo funcional de threads
bajo pintos que deben implementar en todo el sistema de sincronizacion de threads

universidad tecnica federico santa maria, departamento de informatica

10

2.1. cursos implementados en otras universidades

capitulo 2. estado del arte

y manejo de prioridades, ademas de implementar la funcion timer_sleep() para
proporcionar esperas en los procesos.

proyecto 2 user program los alumnos deben simular un disco duro con las propiedades
que trae pintos, se utilizan las funciones de le system para probar esta experiencia.
se debe implementar un sistema que nos indique cuando un proceso ejecutado por
un usuario es nalizado, implementar ademas la funcion process_execute() con
paso de argumentos (ya que la que se encuentra no lo permite) y crear distintas
llamadas a sistemas tales como wait, halt, exec, exit, open entre otros.

proyecto 3 virtual memory el objetivo es quitar la limitacion por hardware de la utili-
zacion de memoria implementando memoria virtual. se debe crear un sistema de
paginacion de segmentos cargados de ejecutables con tal de aproximarse al sistema
lru, implementar el stack growth que aloje estas paginas de segmentos y los per-
misos necesarios para su funcionamiento, y crear las llamadas a sistemas mapid_t y
munmap para el mapeo de memoria.

proyecto 4 file systems los alumnos deben modicar los archivos ya existentes de le
system con tal de agregar una nueva indexacion de archivos segun estimen convenien-
te, crear un manejo de subdirectorios y las llamadas a sistema correspondientes tales
como mkdir, isdir y chdir, crear un buer cache que mantenga los bloques de
archivos utilizados recientemente, y por ultimo crear un sistema de sincronizacion de
lectura/escritura de los archivos del disco.

el curso se encuentra bajo licencia creative commons[5] con atribucion mientras se de
el credito correspondiente. la documentacion del sistema operativo se encuentra libre y
todas las presentaciones de la asignatura se encuentran disponibles para la lectura en su
pagina web[37].

2.1.4. curso de harvard, school of engineering and applied sciences

en la universidad de harvard en la escuela de ingenieros, se dicta el curso cs 161:
operating systems[6] dictado por el profesor margo seltzer. el curso se basa en la construc-

universidad tecnica federico santa maria, departamento de informatica

11

2.1. cursos implementados en otras universidades

capitulo 2. estado del arte

cion y modicacion del kernel os161 complementando con clases lectivas y un proyecto
separado por cinco partes que envuelven los distintos topicos a estudiar.

semanas de duracion
horas/sesiones de clase por semana
horas/sesiones de taller por semana
horas estimadas de dedicacion adicional (semanas)
horas promedio dedicadas por taller

16 semanas
2 sesiones

-

3 horas por clase + 2 proyecto

10 horas

tabla 2.7: horas estimadas curso de harvard, school of engineering and applied sciences

el sistema operativo os161 es provisto por la universidad y esta basado en el sistema
unix. el kernel esta construido con lenguaje assembly x86 y c y viene con los requisitos
minimos necesarios para su funcionamiento y acceso a su propia terminal[6].

participacion en clases

tareas asignadas

prueba 1
prueba 2

ponderacion

10 %
50 %
15 %
25 %

tabla 2.8: ponderaciones curso de harvard

el curso cuenta con videos explicativos y con diapositivas disponibles de forma publica.

el temario de las experiencias es el siguiente:

tarea 0 an introduction to os/161 es un trabajo individual y consiste en un acercamien-
to al codigo que utilizara el alumno durante todo el curso, congurar la maquina
virtual, clonar los repositorios, congurar y construir el kernel, ademas de la utiliza-
cion de git para almacenar todo el proyecto.

tarea 1 synchronization trabajo en equipo de dos personas el cual consiste en conocer
como actualmente os161 esta implementando semaforos. ademas deben implemen-
tar sistemas primitivos de sincronizacion tales como locks y condition variables
para luego probar dicho codigo en problemas planteados de sincronizacion.

tarea 2 system calls and processes en un equipo de dos personas, los alumnos deben
comenzar a construir las piezas faltantes de las llamadas a sistemas que dispone

universidad tecnica federico santa maria, departamento de informatica

12

2.1. cursos implementados en otras universidades

capitulo 2. estado del arte

os161 en lenguaje c para luego correr sys161 en modo usuario y lograr utilizarlas
sin problemas. los estudiantes deben construir mas de 14 funciones que se encuentran
incompletas.

tarea 3 virtual memory como en la experiencia anterior se posibilito la utilizacion de
varios programas, el problema ahora es la falta de memoria para ejecutarlos todos,
por lo que es necesario adaptar os161 para que implemente todo un sistema de
memoria virtual y sistema de paginacion. finalmente el trabajo debe ser funcional al
momento de probar con un programa provisto por el curso que utiliza las funciones
de c malloc y free.

tarea 4 file systems os161 trae implementado un sistema llamado sfs (simple file
system). lo que se espera de la experiencia es que los alumnos modiquen este
sistema y agreguen indexacion, sincronizacion de datos y un sistema de permita
volver a funcionar luego de recibir algun tipo de error de lectura/escritura.

el curso cuenta con toda la documentacion disponible en la red, con contenidos ge-
nerales por topicos, materiales para antes de clases y los repositorios git disponibles
publicamente para su utilizacion[6].

2.1.5. curso de university of illinois at chicago

el curso impartido por la universidad de illinois corresponde a cs 486: secure opera-
ting system design and implementation. el curso, al igual que los anteriores, corresponde
a la construccion de modulos de kernel e implementacion de un sistema operativo (este
sistema se espera que corra en xen). los alumnos deben programar en lenguaje c un
sistema operativo seguro, ya que el programa se basa en ethos[31] el cual es un sistema
operativo open source especializado para evitar ataques externos[30].

el curso se basa principalmente en la construccion del proyecto. las clases presenciales
consisten en presentaciones de avances mas la presentacion del proyecto nal, ademas
de una prueba que envuelve todos los temas tratados durante la construccion del sistema
operativo[30].

universidad tecnica federico santa maria, departamento de informatica

13

2.1. cursos implementados en otras universidades

capitulo 2. estado del arte

semanas de duracion
horas/sesiones de clase por semana
horas/sesiones de taller por semana
horas estimadas de dedicacion adicional (semanas)
horas promedio dedicadas por taller

* no disponible *
* no disponible *
* no disponible *
* no disponible *
* no disponible *

tabla 2.9: horas estimadas curso de university of illinois at chicago

el syllabus no se encuentra disponible publicamente, pero si se encuentran las seis

etapas del proyecto a realizar durante el curso las cuales son:

tarea 0 install vmware on your computer consiste en implementar la zona de trabajo
para toda la asignatura para poder utilizar maquinas virtuales xen en vmware. se
recomienda trabajar bajo fedora 20.

tarea 1 memory/string/printf el trabajo consiste en crear, en lenguaje c, el codigo
necesarias para hacer funcionar las rutinas memcpy, memset, memcmp, strcat,
strncat, strcmp, strncmp, strcpy, strncpy y printf. las funciones de-
ben ser probadas por un programa provisto por el curso.

tarea 2 library/malloc/free se basa en crear las funciones para el manejo de memo-
ria de las aplicaciones a utilizar. este trabajo se debe complementar con la tarea 1 y
debe ser testeado con lo provisto en el curso.

tarea 3 console/timer/events se debe construir una consola para el sistema operati-
vo, mas rutinas de programacion para tener un sistema interactivo de sincronizacion.

tarea 4 page walk fase de creacion de paginas de memorias. el alumno debe imple-
mentar la funcion tablewalk(vaddr) la que permitira la utilizacion de memoria
virtual.

tarea 5 page table create se requiere la implementacion de la funcion virtualmap
quien inicializara el sistema de memoria virtual al arrancar el sistema operativo. se
deben tener en cuenta todos los funcionamientos que este requiera[30].

las presentaciones en diapositivas con la informacion necesaria del curso, parte del
codigo y las explicaciones de cada tarea estan disponibles para todo publico mientras que

universidad tecnica federico santa maria, departamento de informatica

14

2.1. cursos implementados en otras universidades

capitulo 2. estado del arte

se cite su origen. no cuenta con una licencia de distribucion por lo que no se tienen los
permisos necesarios para su utilizacion.

2.1.6. curso de university of california

en la universidad de california, en la division de berkeley computer science, se im-
parte el curso cs194-24: advanced operating systems structures and implementation[16]
con clases lectivas presenciales en donde se explica cada detalle del proceso de diseno y
construccion de un sistema operativo en conjunto con un laboratorio acumulativo de seis
etapas en el que se modica un sistema operativo basado en unix creado para el curso el
cual pueda ser utilizado como webserver[16].

prueba 1
prueba 2
proyecto

participacion en clases

ponderacion

25 %
25 %
45 %
5 %

tabla 2.10: ponderaciones curso de university of california

semanas de duracion
horas/sesiones de clase por semana
horas/sesiones de taller por semana
horas estimadas de dedicacion adicional (semanas)
horas promedio dedicadas por taller

17 semanas

2 clases

-

8 horas
20 horas

tabla 2.11: horas estimadas curso de university of california

los temas abarcados en las clases presenciales se enfocan directamente en lo que se
necesita implementar en el laboratorio. se comienza con las deniciones correspondientes,
las formas de correr el sistema operativo a utilizar y se debate sobre la estructura de
un sistema operativo en si, todo ello en la primera etapa del curso para no topar con la
elaboracion del laboratorio[16]. para ello se forman grupos de dos a tres y los topicos de
cada uno son los siguientes:

lab 0 introduction el objetivo es familiarizar a los alumnos al ambiente en el que traba-
jaran durante toda la asignatura y congurar la maquina virtual, se instala vmware

universidad tecnica federico santa maria, departamento de informatica

15

2.1. cursos implementados en otras universidades

capitulo 2. estado del arte

y se congura de tal forma que corra el sistema operativo unix base que ofrece el
curso.

lab 0.5 fish el objetivo del laboratorio es poder ver por terminal la animacion de un
pescado, con ello se es necesario el conocimiento de llamadas al sistema, mapeo de
memoria, algunas rutinas primitivas de linux y la infraestructura como tal. existe un
archivo base en lenguaje c con las funciones del pescado a implementar utilizando
las pocas herramientas que se tienen.

lab 1 httpd la experiencia de laboratorio consiste en la creacion de puertos de red y
la conguracion de este sistema operativo para que pueda ser un servidor http. es
necesario familiarizarse con el entorno de desarrollo posix.

lab 2 fs en este laboratorio es importante la creacion de le system con la posibilidad de
actualizar informacion, cifrar storage, calcular checksum y rapida recuperacion ante
fallos.

lab 3 scheduling el objetivo es crear el sistema de rutinas de los procesos del sistema
operativo. es importante resaltar que debe funcionar como corresponde ya que
trabajara como web server.

lab 4 device drivers se pide la implementacion de un driver de red para el sistema ope-
rativo. es necesario escribirlo desde cero y se debe realizar para la red proporcionada
por el sistema de virtualizacion, en este caso se trabaja bajo eth194[16].

el curso no cuenta con informacion sobre su distribucion, pero si con la documentacion
de todo el curso y con los repositorios git disponibles para quien los quiera utilizar. es
posible realizar un curso utilizando el mismo material[16].

2.1.7. curso de university of florida

en la universidad de florida, en el department of computer and information science
and engineering se imparte el curso cop 4600: operating systems realizado por el doctor
sumi helal[32]. el curso se centra en el aprendizaje de sistemas operativos, separando

universidad tecnica federico santa maria, departamento de informatica

16

2.1. cursos implementados en otras universidades

capitulo 2. estado del arte

dicho aprendizaje en clases presenciales y experiencias de laboratorio utilizando el pequeno
sistema operativo xinu[8]. el curso se focaliza en el diseno y funcionamiento interno
de un sistema operativo computacional. cubre los conceptos, principios, mecanismos,
politicas, funcionalidades, diseno e implementacion de un sistema operativo que soporte el
funcionamiento de procesos con el principal objetivo de vivir la experiencia de construir
uno propio.

semanas de duracion
horas/sesiones de clase por semana
horas/sesiones de taller por semana
horas estimadas de dedicacion adicional (semanas)
horas promedio dedicadas por taller

15 semanas

2 clases

-

* no disponible *
* no disponible *

tabla 2.12: horas estimadas curso de university of florida

la universidad realiza dos evaluaciones escritas realizadas al inicio y a la mitad del
semestre, un examen nal, cuatro laboratorios y un proyecto grupal en los cuales se trabaja
con xinu.

laboratorios
examenes
proyecto

ponderacion

20 %
60 %
20 %

tabla 2.13: ponderaciones curso de university of florida

este curso no proporciona los metodos de evaluacion para experimentar con el codigo
del sistema operativo xinu. lo unico que revela son sus topicos a pasar en el semestre, los
cuales muestran claramente que son ordenados para la realizacion de los laboratorios al
tener una gran similitud con los temas de los cursos nombrados anteriormente. los temas
son:

the hardware and run-time environment

data structures for operating systems

processes, scheduling and context switching

process management

universidad tecnica federico santa maria, departamento de informatica

17

2.2. sistemas operativos creados para el aprendizaje no utilizados en cursos

capitulo 2. estado del arte

inter-process communication

basic memory management

virtual memory

device-independent input/output

the shell project review

real-time clock management

file systems

mientras el curso se efectua, los alumnos deben de ir leyendo ciertos capitulos del libro
operating system design - the xinu approach[3], el cual corresponde a las instrucciones
de construccion y funcionamiento del sistema operativo utilizado en este curso.

2.2. sistemas operativos creados para el aprendizaje no

utilizados en cursos

2.2.1. crocos 0.2

crocos es un sistema operativo en construccion el cual se esta confeccionando para
su utilizacion en la educacion. es un pequeno kernel de unix para sistemas x86/x64, su
distribucion esta bajo la licencia gnu version 3[33] y se encuentra almacenado mediante
pasos segun el topico en construccion[11].

por el momento solo cuenta con un sistema de administrador de tareas que corre dentro
de un proceso de linux. mas adelante se espera tener mas modulos en el kernel como un
sistema de manejo de memorias, lesystem y mas[11].

la construccion del sistema operativo ha pasado por las siguientes fases:

fase 1: kernel libc

fase 2: administrador de tareas

universidad tecnica federico santa maria, departamento de informatica

18

2.2. sistemas operativos creados para el aprendizaje no utilizados en cursos

capitulo 2. estado del arte

 fase 2.1: un simple administrador de tareas

 fase 2.2: jerarquia de procesos y tareas iniciales

 fase 2.3: senales

 fase 2.4: pila de kernel y de usuario

 fase 2.5: sincronizacion de procesos (mutex)

fase 3: file system de solo lectura

 fase 3.1: leyendo la estructura de le system

 fase 3.2: descriptor de archivos

 fase 3.3: leyendo archivos regulares

 fase 3.4: leyendo directorios

 fase 3.5: \proc le system

y como trabajo futuro la planicacion es:

fase 4: escribir en le system

fase 5: secuencia de boot (para funcionar fuera de un proceso)

fase 6: memoria virtual

fase 7: carga de binarios

fase 8: driver tty

fase 9: utilidades y newlib

el trabajo que se lleva hasta ahora puede ser descargado en la pagina sourceforge y se
encuentra separado segun las fases de desarrollo nombradas anteriormente. de esta forma
el estudiante puede ir analizando paso a paso el trabajo de construccion que se lleva a cabo
para tener un sistema operativo.

no existe hasta el momento una actividad realizable con este proyecto, lamentablemente
este dejo de ser actualizado en abril del ano 2013[11] y no se ve que exista una continuidad
de parte de los desarrolladores.

universidad tecnica federico santa maria, departamento de informatica

19

2.3. alternativas para el aprendizaje buscado

capitulo 2. estado del arte

2.3. alternativas para el aprendizaje buscado

existen varios tutoriales en la red que permiten la elaboracion de un sistema operativo
simple partiendo desde cero, los cuales permiten tener la nocion de las necesidades que se
requieren para la construccion de un sistema mas robusto.

2.3.1. jamesms kernel development tutorials

existe un tutorial del ano 2008 creado por james molly[25] en el cual en 10 etapas nos
permiten tener un sistema operativo. en pocas palabras, esto es lo que se logra en cada
paso:

1. creacion de la base del sistema operativo, directorios, makele y conguracion con

bochs

2. el codigo de booteo para el sistema operativo

3. conguracion de la pantalla, teclado y mouse

4. tablas de memorias

5. manejo de interrupciones

6. paginacion y memoria virtual

7. creacion del heap

8. filesystem y initrd

9. multitasking

10. modo usuario

el tutorial nos permite crear el sistema con lenguaje c y assembly x86 en ciertos
lugares. lo creado es simplemente una de dar a conocer las partes que componen un
sistema operativo[25] .

universidad tecnica federico santa maria, departamento de informatica

20

2.3. alternativas para el aprendizaje buscado

capitulo 2. estado del arte

2.3.2. brans kernel development

es un tutorial de ano 2005 que se basa en la creacion de un sistema operativo para
procesadores superior o igual a 385. su construccion es en lenguaje c y assembly x86, es
similar al tutorial indicado en 2.3.1 pero esta mas centrado en el hardware y esta explicado
con mayor detalle. los pasos para la construccion se basan en los siguientes temas:

1. la entrada de kernel y el script linker

2. creacion de main() y el link del codigo c

3. imprimir por pantalla

4. implementacion de global descriptor table

5. implementacion de interrupt descriptor table

6. rutinas de interrupciones

7. peticiones de interrupcion (irq) y controles programables de interrupcion (pic)

8. implementacion de system clock

9. teclado

luego el tutorial lo deja a libre disposicion del usuario, con ideas tales como agregar
multitasking, memoria virtual, congurar nuevos drivers vga para obtener mas colores o
vesa para videos y mayor resoluciones[12].

mientras se realizan los pasos de este tutorial, este mismo va explicando de forma
supercial los topicos minimos necesarios para conocer que es lo que se esta haciendo. se
estima un trabajo de no mas de una hora por cada uno de los temas.

universidad tecnica federico santa maria, departamento de informatica

21

2.3. alternativas para el aprendizaje buscado

capitulo 2. estado del arte

universidad tecnica federico santa maria, departamento de informatica

22

capitulo 3. evaluacion de sistemas

3 | evaluacion de sistemas

cada metodo de aprendizaje nombrado en el capitulo 2 sera evaluado segun la informa-
cion que es posible aprender, los temas a los cuales aborda y que tiene y que no tiene que
hacer el alumno para avanzar en dichos cursos, ademas de evaluar la cantidad de lineas de
codigo que se esperan construir, siempre y cuando los cursos nombrados tengan disponible
su informacion de forma liberada.

los cursos fueron comparados mediante la existencia de los siguientes temas y la

participacion del alumno en cada una de ellas:

sistema operativo base corresponde a la existencia de archivos en los cuales basarse
para la construccion del sistema operativo. estos pueden ser archivos con cabeceras
de funciones como tambien carpetas. solo corresponde a su estructura y no a codigo.

sistema de booteo base codigo correspondiente al iniciador del sistema operativo. puede
estar completo o no. en caso de que codigo se encuentre presente, este debe escoger
correctamente el sistema operativo a mostrar.

kernel base para sistema operativo codigo que corresponde a un kernel base con po-

sibilidades de ser modicado.

stack base para sistema operativo sistema basico de manejo de memoria para ser uti-

lizado por el sistema operativo y sus procesos[40].

gestion de paginas fisicas codigo base para el principio de memoria virtual. la forma
con la cual los procesos estan repartidos en forma de paginas para ser cargados,
ayudando al hardware de gestion de memoria y optimizando el espacio. [40]

universidad tecnica federico santa maria, departamento de informatica

23

capitulo 3. evaluacion de sistemas

memoria virtual codigo que corresponde a la memoria virtual. conguracion que es
necesaria cuando la memoria es ocupada en su totalidad y se requiere de algun
metodo de mitigacion para seguir utilizandola con ayuda de un almacenamiento
secundario[40].

memoria de kernel codigo que corresponde a la reserva de memoria asignada netamente

al uso del kernel del sistema operativo.

manejo de interrupciones y excepciones corresponde a la construccion de un sistema
que permita interactuar con procesos que requieran necesariamente una interrupcion
del sistema, con la implementacion de la lista idt, lo mismo para el manejo de
excepciones. debe soportar tanto las interrupciones, las cuales son de origen externo,
y las excepciones que son de origen interno[40].

soporte de multiprocesos corresponde a la creacion de codigo que permita la existencia
de mas de un proceso funcionando a la vez en el sistema operativo. este puede ser
simetrico o asimetrico[28].

procesos y fork codigo que corresponde a la utilizacion del concepto proceso para un
trabajo. ademas tambien de la creacion del sistema fork para la creacion de procesos
hijos.

comunicacion entre procesos parte del sistema operativo que permita la interaccion
entre los procesos, involucrando los topicos anteriores de fork, multiprocesos e
interrupciones y excepciones.

file system creacion de un sistema que interactue con archivos. codigo que sirva a nivel

de usuario para crear, vericar e incluso usar archivos y directorios.

llamadas a sistema codigo que corresponde a las aplicaciones que se encargan de reali-
zar la comunicacion hacia el kernel para realizar operaciones a peticion del usuario.

la interfaz teclado codigo que permita la interaccion de la interfaz i/o de teclado.

la interfaz mouse codigo que permita interactuar con el mouse en el sistema operativo.

universidad tecnica federico santa maria, departamento de informatica

24

capitulo 3. evaluacion de sistemas

la interfaz vga codigo que abarca la utilizacion de una pantalla vga, siendo esto el

manejo de colores, resoluciones y otros temas a nes de visualizacion.

la terminal y modo usuario corresponde a la creacion de una terminal que contenga

aplicaciones seguras para el sistema operativo que tienen llamadas a sistema.

servicio network conguraciones mediante codigo para la creacion de la interaccion del

sistema operativo para su utilizacion mediante conexion de red.

ideas libres del alumno espacio para que el alumno pueda agregar lo que desee al sistema

operativo trabajado.

para cada tabla resolutiva solo se adjuntaran los temas que abarca cada curso y su
respectivo laboratorio en el cual se encuentra, tambien se mostrara como es la participacion
del alumno en cada uno de ellos.

simbolo

 

 

corresponde a

implementado totalmente por el alumno
proporcionado por el sistema
proporcionada una base, desarrollada por el alumno

tabla 3.1: simbolos para representar participacion del alumno por cada tema.

por otro lado, los cursos seran evaluados segun su disponibilidad de informacion y su
utlima fecha de actualizacion, para asi tener una clara denicion de cual curso se puede
utilizar para nuestro proposito.

universidad tecnica federico santa maria, departamento de informatica

25

3.1. cursos para comparar

capitulo 3. evaluacion de sistemas

3.1. cursos para comparar

3.1.1. curso de massachusetts institute of technology

el curso basado en la modicacion del sistema operativo xv6 esta disponible para
su libre uso mientras que este se le referencie su origen de procedencia. el codigo fue
descargado y compilado segun la documentacion anexada en la seccion a.1 sin presentar
inconveniente alguno. se logra encontrar un codigo incompleto preparado para que se
puedan realizar las experiencias listadas en documentos separados.

el curso ademas cuenta con la materia disponible (reejado en la tabla 3.2) segun
el orden el cual es pasada teniendo una clara similitud entre lo pasado en clases y lo
experimentado. se da a conocer que el curso consta de horas de clases y horas de trabajo
para las experiencias practicas[22].

la ultima modicacion conocida en el curso fue realizada el mes de noviembre del

ano 2015 esencialmente en el codigo publico git[22].

1





laboratorio

tema
sistema operativo base
sistema de booteo base
kernel base para sistema operativo
stack base para sistema operativo
gestion de paginas fisicas
memoria virtual
memoria de kernel
manejo de interrupciones y excepciones
soporte de multiprocesos
procesos y fork
comunicacion entre procesos
file system
la interfaz vga
la interfaz teclado
la terminal y modo usuario
servicio network
ideas libres del alumno

2

3

4

5

6

7

 
 
 

 

 
 
 

 
 
 
 

 

 

tabla 3.2: tabla comparativa de temas abordados por el curso de massachusetts institute of
technology

universidad tecnica federico santa maria, departamento de informatica

26

3.1. cursos para comparar

capitulo 3. evaluacion de sistemas

3.1.2. curso de carnegie mellon university

este curso es bastante completo, da a su disposicion todo su material referente a
lo pasado en clases, ademas de ofrecer presentaciones en ppt. el codigo se encuentra
disponible solo para realizar las primeras dos experiencias; para las demas se encuentran
especialmente para uso de los estudiantes de su universidad.

cuenta con dos clases presenciales semanalmente por 16 semanas y se enfoca netamente
en el aprendizaje de sistemas operativos basados en el libro operating systems: principles
and practic y las experiencias practicas estan contempladas para realizarse fuera de clases
por lo que son de baja dicultad[1][7].

como no se pudo indagar en el contenido de las experiencias 3 y 4 del curso, la
tabla 3.3 quedo incompleta y la evaluacion fue realizada con la informacion disponible en
las experiencias 1 y 2.

la ultima modicacion conocida para este curso fue realizado el mes de noviembre
del ano 2015 y fue principalmente en la actualizacion de los archivos pdf disponibles
publicamente[7].

laboratorio

tema

inspeccion de lenguaje c
sistema operativo base
sistema de booteo base
kernel base para sistema operativo
stack base para sistema operativo
la interfaz teclado
la interfaz mouse
la terminal y modo usuario
manejo de interrupciones y excepciones

1
 


2

3

4




 
 
 
 

tabla 3.3: tabla comparativa de temas abordados por el curso de carnegie mellon university

universidad tecnica federico santa maria, departamento de informatica

27

3.1. cursos para comparar

capitulo 3. evaluacion de sistemas

3.1.3. curso de standford university

el desarrollo de las experiencias practicas en este curso se basa principalmente en
la modicacion del sistema operativo pintos en su expresion mas pequena posible, de
tal forma que los alumnos puedan hacerlo robusto. dichas experiencias son de caracter
acumulativo y estan planicadas para ser desarrolladas fuera del transcurso de clases[38].
cuenta con horarios de clases semanales y horarios de consulta para el desarrollo de
las experiencias. el codigo se encuentra disponible y fue posible ser compilado segun
la documentacion adjunta en la seccion a.3, encontrandonos con un kernel base para
modicar, ya que sin modicar tenemos una terminal con operaciones basicas incompletas.
cada una de las experiencias toca un punto importante esencial que debe contener un kernel
funcional, tal como lo podemos ver en la tabla 3.4[38].

el curso presenta una ultima actualizacion para diciembre del ano 2009. [38]

laboratorio

tema

sistema operativo base
comunicacion entre procesos
soporte de multiprocesos
la terminal y modo usuario
memoria virtual
file system

0

 

1

 

2


 

3


 

4


 

tabla 3.4: tabla comparativa de temas abordados por el curso de standford university

3.1.4. curso de harvard, school of engineering and applied sciences

el curso cuenta con 5 experiencias practicas separadas por topicos segun la tabla 3.5
en las cuales se trabaja en base a la modicacion del sistema os 161 el cual permite su
modicacion agregando codigo en lenguaje c. el curso cuenta con toda la informacion
disponible de forma publica, incluso con repositorios especiales para ello para dar la
oportunidad de que cualquier persona pueda aportar a su codigo[6].

ademas cuenta con una maquina virtual que trabaja en vmware la cual es posible
descargar y contiene las herramientas necesarias para llegar y trabajar. entonces, copiando

universidad tecnica federico santa maria, departamento de informatica

28

3.1. cursos para comparar

capitulo 3. evaluacion de sistemas

el repositorio git dentro de esta maquina, es posible correr el sistema operativo segun lo
documentado en la seccion a.5. el codigo ademas trae programas predenidos que validan
si la tarea realizada esta trabajando correctamente[6].

en su pagina ocial es posible descargar la materia de forma ordenada ademas de las
presentaciones en ppt para cada una de las clases semanales efectuadas. las experiencias
son realizadas fuera del horario de clases.

la ultima modicacion conocida fue realizada en el codigo git el mes de junio del ano

2015[6].

laboratorio

tema

sistema operativo base
sistema de booteo base
kernel base para sistema operativo
stack base para sistema operativo
soporte de multiprocesos
procesos y fork
llamadas al sistema
memoria virtual
file system

0





1

2

3

4

 

 
 

 

 

tabla 3.5: tabla comparativa de temas abordados por el curso de harvard, school of engineering
and applied sciences

3.1.5. curso de university of illinois at chicago

el curso esta enfocado directamente en la creacion de un sistema operativo seguro, por
lo mismo las experiencias practicas realizadas estan efectuadas en base al sistema operativo
ethos[31] que cumple con dicho proposito[30].

las clases son de caracter online y solo es necesario asistir los dias de presentaciones
de avances de las experiencias. dichas clases se encuentran disponibles publicamente en
formato de diapositivas.

las experiencias practicas 1 y 2 son las que se encuentran de forma publica siendo las
otras tres experiencias privadas solo para los alumnos de dicha universidad. los topicos
representados en la tabla 3.6 fueron encontrados gracias a que los documentos instructivos

universidad tecnica federico santa maria, departamento de informatica

29

3.1. cursos para comparar

capitulo 3. evaluacion de sistemas

para las experiencias se encuentran parcialmente disponibles (cuentan con el enunciado a
desarrollar sin ningun tipo de guia para avanzar)[30].

la ultima actualizacion conocida de este curso fue realizada en marzo del ano 2012 el

cual fue la fecha en la que se nalizo el curso. [30]

laboratorio

tema

sistema operativo base
sistema de booteo base
kernel base para sistema operativo
stack base para sistema operativo
llamadas al sistema
memoria virtual
gestion de paginas fisicas

0





1

2

3

4

5

 
 

 
 

 

 

 

tabla 3.6: tabla comparativa de temas abordados por el curso de university of illinois at chicago

3.1.6. curso de university of california

el curso cuenta con clases lectivas especializadas en la construccion de un sistema
operativo para ser utilizado como webserver. se encuentra estructurado con horas de clases
y horas practicas de laboratorio, en las que se debe trabajar en ellas en conjunto con
asistencia del profesor[16].

los contenidos del curso se encuentran disponibles en su pagina web tanto la materia, las
presentaciones en diapositivas y los documentos que guian en el trabajo de las experiencias,
reejado en la tabla 3.7. el curso se encuentra bastante completo para el objetivo principal
que buscan.

en cambio, el codigo a modicar no se encuentra disponible ya que fue retirado de los
servidores de la universidad con lo que se hizo imposible realizar algun tipo de trabajo en
el.

la ultima vez que se dicto el curso coincide con la fecha de su ultima actualizacion en

los documentos, el cual es mayo del ano 2014[16].

universidad tecnica federico santa maria, departamento de informatica

30

3.1. cursos para comparar

capitulo 3. evaluacion de sistemas

laboratorio

tema

sistema operativo base
sistema de booteo base
kernel base para sistema operativo
stack base para sistema operativo
llamadas a sistema
gestion de paginas fisicas
la interfaz vga
soporte de multiprocesos
comunicacion entre procesos
memoria virtual
memoria de kernel
servicio network

0





0.5

1

2

3

4

 
 
 

 
 
 
 
 

 

 

 

 

 

tabla 3.7: tabla comparativa de temas abordados por el curso de university of california

3.1.7. curso de university of florida

el curso de sistemas operativos se complementa con experiencias practicas basadas en
la modicacion del sistema operativo xinu con el objetivo de mejorar y agregar distintos
modulos a este.

el curso no cuenta con un codigo especial, ya que se basa en el orden de aprendizaje
del libro operating system design: the xinu approach, second edition[3] el cual trae su
propio sistema, el cual fue probado y ejecutado segun la documentacion anexada en la
seccion a.4.

la informacion del curso se limita a su existencia y no comparte sus documentos
utilizados. los topicos indicados en la tabla 3.8 son los indicados en la descripcion del
curso y no necesariamente son los que estan incluidos en las experiencias practicas[32].

la ultima actualizacion de la informacion del curso fue realizada en abril del ano

2015[32].

3.1.8. crocos 0.2

el sistema operativo crocos no es un curso pero esta orientado para el aprendizaje, ya
que su codigo se encuentra separado en etapas de construccion segun los topicos necesarios

universidad tecnica federico santa maria, departamento de informatica

31

3.1. cursos para comparar

capitulo 3. evaluacion de sistemas

laboratorio

tema

sistema operativo base
sistema de booteo base
kernel base para sistema operativo
stack base para sistema operativo
procesos y fork
comunicacion entre procesos
gestion de paginas fisicas
memoria virtual
memoria de kernel
la terminal y modo usuario
file system

todos





 
 
 
 
 
 
 

tabla 3.8: tabla comparativa de temas abordados por el curso de university of florida

a abordar. el sistema no se encuentra completo y se nota claramente que fue abandonado
por la comunidad debido a que su ultima actualizacion se realizo en abril del ano 2013
luego de haber presentado actualizaciones periodicas de no mas de 2 dias de diferencia en
su repositorio[11].

como no es un curso no cuenta con material de estudio ni con presentaciones disponi-

bles. los temas presentados en la tabla 3.9 son los que actualmente abarca[11].

fases
tema

sistema operativo base
sistema de booteo base
kernel base para sistema operativo
stack base para sistema operativo
soporte de multiprocesos
procesos y fork
file system

1





2

3






tabla 3.9: tabla comparativa de temas abordados por el so crocos 0.2

3.1.9. jamesms kernel development tutorials

a pesar de que no es un curso, se considera como posibilidad por ser un tutorial
que construye un kernel funcional. esta basado en el trabajo de bran explicado en la
seccion 2.3.2.

universidad tecnica federico santa maria, departamento de informatica

32

3.1. cursos para comparar

capitulo 3. evaluacion de sistemas

al realizar el tutorial por completo el resultado es un sistema operativo que contiene
operaciones basicas de ejecucion hasta llamadas a sistema, tal como se muestra en la
tabla 3.10[25].

el tutorial es desarrollado totalmente por el alumno y es explicado paso a paso, dando

explicaciones de funcionalidad y estructura.

el desarrollo de este material fue nalizado en abril del 2008, teniendo aun vigencia
para los equipos actuales. de hecho, fue compilado y probado segun la documentacion
adjunta en la seccion a.2[25].

tema
sistema operativo base
sistema de booteo base
kernel base para sistema operativo
stack base para sistema operativo
la interfaz vga
gestion de paginas fisicas
manejo de interrupciones y excepciones
memoria virtual
memoria de kernel
file system
comunicacion entre procesos
llamadas a sistema

realizado por

 
 
 
 
 
 
 
 
 
 
 
 

tabla 3.10: tabla comparativa de temas abordados por el tutorial de jamesm

3.1.10. brans kernel development

al igual que el tutorial realizado por james, fue considerado dentro de este estudio por

ser un tutorial que crea un kernel funcional.

este tutorial cuenta con menos temas abordados que el tutorial de james lo se ve
reejado en la tabla 3.11, pero cuenta con otros temas de reconocimiento de interfaz
graca y manejos de interfaces de teclado[12].

como es un tutorial, el desarrollo del codigo es realizado por completo. podemos ver

un ejemplo de ejecucion de este en la documentacion generada en la seccion a.6.

por ultimo, el tutorial fue nalizado y publicado en marzo del 2007[12].

universidad tecnica federico santa maria, departamento de informatica

33

3.2. resumen, tablas comparativas

capitulo 3. evaluacion de sistemas

tema
sistema operativo base
sistema de booteo base
kernel base para sistema operativo
stack base para sistema operativo
la interfaz vga
gestion de paginas fisicas
manejo de interrupciones y excepciones
la interfaz teclado

realizado por

 
 
 
 
 
 
 
 

tabla 3.11: tabla comparativa de temas abordados por el tutorial de bran

3.2. resumen, tablas comparativas

para un mejor orden en las tablas 3.13, 3.14, 3.15, 3.16 y 3.17, se decidio representar
cada curso por una sigla la cual puede representar el nombre del curso implementado como
tambien el sistema operativo que modican durante el curso. dichas siglas estan ordenadas
en la tabla 3.12.

curso

curso de massachusetts institute of technology
curso de carnegie mellon university
curso de standford university
curso de harvard, school of engineering and applied sciences
curso de university of illinois at chicago
curso de university of california
curso de university of florida
crocos 0.2
jamesms kernel development tutorials
brans kernel development

sigla
xv6

15-410
pintos
cs 161
ethos

cs194-24

xinu
crocos
james
bran

tabla 3.12: representacion de los cursos en siglas para las siguientes tablas.

universidad tecnica federico santa maria, departamento de informatica

34

3.2.1. comparacion con respecto a los contenidos ofrecidos

cada uno de los cursos fue evaluado segun su disponibilidad de contenido. en la tabla 3.13 podemos ver una clara comparacion entre

los cursos que ofrecen mas contenidos independiente de su disponibilidad de estos.

sistema operativo base
sistema de booteo base
kernel base para sistema operativo
stack base para sistema operativo
gestion de paginas fisicas
memoria virtual
memoria de kernel
manejo de interrupciones y excepciones
soporte de multiprocesos
procesos y fork
comunicacion entre procesos
file system
llamadas al sistema
la interfaz teclado
la interfaz mouse
la interfaz vga
la terminal y modo usuario
servicio network
ideas libres del alumno





 
 
 
 
 
 

xv6 cs194-24




 
 
 
 
 
 
 
 
 
 
 
 
 

 
 

 
 
 
 
 
 
 
 

 
 
 

 





 

 
 
 
 





 
 
 
 
 
 
 

 
 
 

 

james pintos xinu cs 161 ethos bran
 
 
 
 
 
 
 





 
 
 





 
 
 

15-410 crocos















 

 
 

 

 

tabla 3.13: tabla comparativa de temas abordados por todos los cursos.

u
n
i
v
e
r
s
i
d
a
d
t
e
c
n
i
c
a
f
e
d
e
r
i
c
o
s
a
n
t
a

m

a
r
i
a
,

d
e
p
a
r
t
a
m
e
n
t
o

d
e

i
n
f
o
r
m
a
t
i
c
a

3
5

3

.

2

.

r
e
s
u
m
e
n

,

t
a
b
l
a
s
c
o
m
p
a
r
a
t
i
v
a
s

c
a
p
i
t
u
l
o
3

.

i

e
v
a
l
u
a
c
o
n
d
e
s
i
s
t
e
m
a
s

3.2.2. comparacion con respecto a su disponibilidad y ultima actualizacion

las tablas 3.14 y 3.15 muestran la disponibilidad de informacion que ofrecen los cursos hacia el publico en general. esto considera
un codigo existente y compilable, materia de la cual es posible leer por completo el curso, presentacion en proyecciones con cada clase
implementada y la existencia de documentos guias que sirvan de instructivos para realizar las experiencias practicas con respecto a la
modicacion de un kernel real. por ultimo, se registra la fecha en la cual se realizo una ultima modicacion en el curso con respecto a su
codigo e informacion general.

cs 161

pintos cs194-24

codigo compilable
materia del curso incluido
presentaciones en proyecciones
documentos guias para experiencias
fecha ultima actualizacion

si
si
si
si

xv6
si
si
no
si

11-2015

si
si
no
si

no
si
si
si

15-410
parcial

si
si
si

06-2015

12-2009

05-2014

11-2015

tabla 3.14: tabla comparativa de disponibilidad de contenidos (1).

codigo compilable
materia del curso incluido
presentaciones en proyecciones
documentos guias para experiencias
fecha ultima actualizacion

james

si
si
no
no

04-2008

bran
si
si
no
no

03-2007

xinu
si
no
no
no

04-2015

ethos
parcial

no
si

solo enunciados

03-2012

tabla 3.15: tabla comparativa de disponibilidad de contenidos (2).

crocos

si, incompleto

no
no
no

04-2013

u
n
i
v
e
r
s
i
d
a
d
t
e
c
n
i
c
a
f
e
d
e
r
i
c
o
s
a
n
t
a

m

a
r
i
a
,

d
e
p
a
r
t
a
m
e
n
t
o

d
e

i
n
f
o
r
m
a
t
i
c
a

3
6

3

.

2

.

r
e
s
u
m
e
n

,

t
a
b
l
a
s
c
o
m
p
a
r
a
t
i
v
a
s

c
a
p
i
t
u
l
o
3

.

i

e
v
a
l
u
a
c
o
n
d
e
s
i
s
t
e
m
a
s

3.2.3. comparacion con respecto a los tiempos necesarios para realizar los cursos

cada uno de los cursos que se encuentran ya implementados en otras universidades cuentan con clases estructuradas para las estructuras
segun sus intereses a explicar, la tabla 3.16 resume la cantidad de horas estimadas ocupadas para cada una de ellas. cabe mencionar que
las horas son estimadas y no necesariamente representan la realidad.

semanas de duracion (semanas)
sesiones de clase por semana (sesiones)
horas/sesiones de taller por semana
horas estimadas de dedicacion adicional (semanas)
horas promedio dedicadas por taller

xv6
16
2
-
4
9

15-410 pintos cs 161 ethos cs194-24 xinu
15
2
-
-
-

16
2
-
3
7.5

17
2
-
8
20

10
3
1
15
25

16
2
-
2
10

-
-
-
-
-

tabla 3.16: horas estimadas para todos los cursos investigados implementados en otras universidades

u
n
i
v
e
r
s
i
d
a
d
t
e
c
n
i
c
a
f
e
d
e
r
i
c
o
s
a
n
t
a

m

a
r
i
a
,

d
e
p
a
r
t
a
m
e
n
t
o

d
e

i
n
f
o
r
m
a
t
i
c
a

3
7

3

.

2

.

r
e
s
u
m
e
n

,

t
a
b
l
a
s
c
o
m
p
a
r
a
t
i
v
a
s

c
a
p
i
t
u
l
o
3

.

i

e
v
a
l
u
a
c
o
n
d
e
s
i
s
t
e
m
a
s

3.3. analisis de los datos

capitulo 3. evaluacion de sistemas

3.2.4. comparacion con respecto al tamano del kernel a modicar

lo siguiente es una comparacion con respecto al tamano en kb del sistema operativo
que contienen los cursos a los cuales se le es posible compilar su codigo. la idea de
realizar esta medicion es para analizar de alguna forma la complejidad que podria tener
al momento de abordar a realizar dicho curso. la tabla 3.17 reeja los datos obtenidos
para cada uno de ellos. notamos como es que el sistema operativo xinu tiene un tamano
bastante diferenciado del resto, y esto es porque xinu es un sistema operativo ya utilizado
en dispositivos, mas recientemente en dispositivos portatiles como las raspberry[39].

curso
cs-161

xv6
pintos
xinu
james
brand

tamano [kb]

560
291
244
7334
366
110

tabla 3.17: tabla comparativa de tamanos de sistemas operativos de cursos con codigo compilable

3.3. analisis de los datos

llegado a este punto nos queda comenzar a trabajar con los datos obtenidos. se necesita
converger a uno de los cursos evaluados para poder cumplir el objetivo de adaptar un curso
para el departamento de informatica.

se utilizan distintos discriminantes para poder escoger de mejor forma el curso que se

tomara a futuro, y se escogieron las mas relevantes, tales son:

1. si posee un codigo compilable para trabajar en el.

2. si su actividad de actualizacion es reciente.

3. cuenta con libro guia en cual estudiar las experiencias.

4. cuenta con experiencias ya realizadas.

universidad tecnica federico santa maria, departamento de informatica

38

3.3. analisis de los datos

capitulo 3. evaluacion de sistemas

3.3.1. caracteristicas de su codigo

el objetivo de esta variable es conocer si los cursos cuentan con un codigo el cual se
pueda descargar, compilar y ejecutar para simular su sistema operativo, claramente con la
idea de seguir recompilando luego de realizar las modicaciones pertinentes.

con ello, y gracias a las tablas 3.14 y 3.15 escogeremos solo a los sistemas operativos

que cuenten con ello.

curso

curso de massachusetts institute of technology
curso de carnegie mellon university
curso de standford university
curso de harvard, school of engineering and applied sciences
curso de university of illinois at chicago
curso de university of california
curso de university of florida
crocos 0.2
jamesms kernel development tutorials
brans kernel development

codigo compila

si
no
si
si
no
no
si
no
si
si

tabla 3.18: extracto de tablas 3.14 y 3.15 con respecto a compilacion.

por lo que nos quedamos con solo seis de los diez cursos propuestos, varios de ellos no
pueden ser utilizados por privacidad de su codigo u otros no contaban con los requisitos de
ser compilables.

3.3.2. ultima actividad conocida

esta variable nos indica si el curso en cuestion fue modicado o cuenta con actividades
con fechas de no mas de un ano hasta la actualidad. con esto aprovechamos de utilizar
caracteristicas que solo las ultimas tecnologias nos otorgan, como mejores programas de
debug, simuladores y compiladores.

aqui notamos que los tutoriales indicados como alternativas de aprendizaje quedaron
atras a causa de que usan tecnologias del ano 2007. algo similar ocurre con el curso de
standford university ya que no presentaba actividad del ano 2009.

universidad tecnica federico santa maria, departamento de informatica

39

3.3. analisis de los datos

capitulo 3. evaluacion de sistemas

curso

curso de massachusetts institute of technology
curso de standford university
curso de harvard, school of engineering and applied sciences
curso de university of florida
jamesms kernel development tutorials
brans kernel development

actualizacion en

el ultimo ano

si
no
si
si
no
no

tabla 3.19: extracto de tablas 3.14 y 3.15 con respecto a ultima actualizacion.

3.3.3. existencia de libro guia

la idea de considerar esta variable como importante, es que el curso cuente con un
libro en el cual sea posible utilizar como referencias para estudiar sobre el desarrollo de las
experiencias a realizar durante el semestre, por lo que se considerara las que si lo posean.

curso

curso de massachusetts institute of technology
curso de harvard, school of engineering and applied sciences
curso de university of florida

cuenta con
libro guia

si [29]

no
si [3]

tabla 3.20: cursos considerados que cuentan con libro guia.

entre los tres cursos disponibles hasta el momento, el que no cuenta con un libro guia es
el curso de harvard a pesar de que si es posible conseguir de forma libre sus presentaciones
de diapositivas. se considero mas importante debido a que, con los libros respectivos de los
dos cursos restantes, se encuentra un orden en el cual es posible realizar una ensenanza
estructurada para nuestra universidad.

3.3.4. experiencias aplicadas en sus cursos

esta variable fue considerada una de las importantes al comienzo del estudio. consiste
en conocer si el curso en cuestion posee experiencias practicas ya redactadas y estructuradas
en un orden en el cual cualquier interesado en el curso pueda desarrollar para su bien propio.
se considerara el curso que si cuente con ellas.

en este caso, el curso de university of florida estructuro el curso gracias al libro

universidad tecnica federico santa maria, departamento de informatica

40

3.3. analisis de los datos

capitulo 3. evaluacion de sistemas

curso

curso de massachusetts institute of technology
curso de university of florida

cuenta con
experiencias

si
no

tabla 3.21: cursos considerados que cuentan con experiencias practicas pre-construidas.

de xinu[3] y las experiencias, las cuales no estaban disponibles, seguian el orden de los
capitulos de este. en cambio, para el curso de massachusetts, cuenta con siete experiencias
ordenadas de forma incremental.

universidad tecnica federico santa maria, departamento de informatica

41

3.3.5. conclusiones luego del analisis

finalmente, el curso que cumple con todas estas variables corresponde al implantado en massachusetts institute of technology

utilizando el sistema operativo xv6. en la tabla 3.22 vemos un resumen de lo considerado en el proceso de seleccion.

curso

curso de massachusetts institute of technology
curso de carnegie mellon university
curso de standford university
curso de harvard, school of engineering and applied sciences
curso de university of illinois at chicago
curso de university of california
curso de university of florida
crocos 0.2
jamesms kernel development tutorials
brans kernel development

si
no
si
si
no
no
si
no
si
si

tabla 3.22: resumen, discriminacion de cursos.

codigo compila actualizacion en
el ultimo ano

cuenta con
libro guia

si


no


si




cuenta con
experiencias

si





no




si

no
si


si

no
no

u
n
i
v
e
r
s
i
d
a
d
t
e
c
n
i
c
a
f
e
d
e
r
i
c
o
s
a
n
t
a

m

a
r
i
a
,

d
e
p
a
r
t
a
m
e
n
t
o

d
e

i
n
f
o
r
m
a
t
i
c
a

4
2

3

.

3

.

a
n
a
l
i
s
i
s
d
e
l
o
s
d
a
t
o
s

c
a
p
i
t
u
l
o
3

.

i

e
v
a
l
u
a
c
o
n
d
e
s
i
s
t
e
m
a
s

capitulo 4. implementacion del curso

4 |

implementacion del curso

el curso que se utilizara como base segun la conclusion obtenida por el capitulo 3 es
el curso curso de massachusetts institute of technology el cual cuenta con una licencia
de atribucion cc by 3.0 us[4] con lo que es posible la utilizacion de su contenido y su
modicacion mientras exista un reconocimiento de su origen.

como ya se habia comentado, este curso trata el tema de la ensenanza de sistemas
operativos mediante la experimentacion practica de modicar uno, en este caso se utiliza
xv6 el cual se le realizan aportes a sus modulos para asi mejorar su kernel y cumplir con
mas funciones. dicho trabajo esta separado en 7 laboratorios practicos de los cuales 5 son
obligatorios y los ultimos opcionales.

para el curso que se desea implementar, contara con dos horas lectivas semanales
durante 16 semanas, las cuales se estructuraran solo utilizando 15 de ellas y sera de tal
forma que la primera hora sea de clase en donde se repasaran los elementos necesarios para
realizar la experiencia correspondiente a esa semana y la segunda hora se utilizaria para
trabajar en las experiencias con asistencia del profesor y/o ayudantes.

en el anexo b encontramos el desarrollo del curso tal como lo ofrece actualmente el
mit. la adaptacion que se hara con respecto a lo visto ahi sera que solo se consideraran
cinco laboratorios distribuidos durante el semestre. un punto clave a considerar es que
el codigo con las respuestas a los desafios planteados en las experiencias se encuentra
disponible publicamente, por lo que se necesita de un metodo para solucionar esto.

universidad tecnica federico santa maria, departamento de informatica

43

4.1. curso modificado para el departamento de informaticacapitulo 4. implementacion del curso

4.1. curso modicado para el departamento de informa-

tica

el curso cuenta con un repositorio git con un esqueleto del sistema operativo xv6 el
cual esta separado por ramas segun el laboratorio a realizar. el codigo esta construido de
forma evolutiva con el objetivo de ir reutilizando lo realizado en las experiencias anteriores.

el codigo se encuentra en:

https://github.com/csfuente/labsxv6/tree/master

las instrucciones para el uso de este repositorio se encontraran en cada uno de los

documentos instructivos que seran entregados para cada una de las experiencias.

las experiencias estan preparadas para ser desarrolladas individualmente o en grupo de
a dos personas. cada grupo debe generar su propio repositorio git en donde debe realizar
su entrega (idealmente utilizando los servidores git del departamento de informatica).

las experiencias se encuentran adjuntas en el anexo digital como tambien una plantilla

base para el programa de la asignatura.

4.1.1. objetivos

1. crear y editar codigo que permita ser utilizado en el kernel de un sistema operativo.

2. identicar los distintos modulos y su relacion con las funcionalidades del sistema

operativo.

3. experimentar el proceso de construccion de un sistema operativo simple.

4.1.2. contenidos

al igual que las primeras cinco experiencias del curso del mit, los contenidos aplicados

en las experiencias del curso son:

1. booteo del sistema operativo

universidad tecnica federico santa maria, departamento de informatica

44

4.1. curso modificado para el departamento de informaticacapitulo 4. implementacion del curso

2. manejo de memoria

3. ambiente de usuario

4. sistema de multitareas

5. file system, spawn y terminal

4.1.3. evaluaciones

se trabajaran 5 experiencias en las cuales abarcaran los temas representados en la
seccion 4.1.2 y se aplicara un bonus de un 5 % para quienes deseen aumentar su nota nal.
dicha bonicacion consiste en agregar al sistema operativo algo nuevo el cual se demuestre
una nueva funcionalidad, no es necesario que funcione perfectamente.

el curso contara con cinco evaluaciones las que se deben realizar posterior a la fecha
de entrega de cada una de las experiencias. cada una de las evaluaciones se centraran
directamente en la experiencia realizada segun los topicos resueltos en estos.

las ponderaciones estan representadas en la tabla 4.1 las cuales cada una cuenta con

una nota entre 0 a 100 y estan planicadas equitativamente durante el semestre.

experiencia 1
experiencia 2
experiencia 3
experiencia 4
experiencia 5
promedio evaluaciones
bonus

ponderacion

8 %
13 %
13 %
13 %
13 %
40 %
5 %

tabla 4.1: ponderaciones de curso propuesto.

universidad tecnica federico santa maria, departamento de informatica

45

4.1. curso modificado para el departamento de informaticacapitulo 4. implementacion del curso

4.1.4. programacion

semana

1

2

3

4
5

6

7

8

9

10

11

12

13
14
15

clase 1

- clase introductoria
- clase lectiva para experiencia 1
- conocimiento de herramientas a utilizar
- correr el sistema operativo
- direcciones fisicas, bios, kernel, stack.
- desarrollo de experiencia 1
- clase lectiva para experiencia 2
- manejo de memoria fisica, memoria
virtual, direcciones de memoria de kernel
- entrega de experiencia 1
- desarrollo de experiencia 2
- desarrollo de experiencia 2
- clase lectiva para experiencia 3 parte a
- modo usuario y manejo de excepciones
- entrega de experiencia 2
- desarrollo de experiencia 3
- clase lectiva para experiencia 3 parte b
- fallas de paginas, excepciones de punto
de quiebre, llamadas a sistema.
- desarrollo de experiencia 3
- clase lectiva para experiencia 4 parte a
- soporte de multiprocesos, multitasking
- entrega de experiencia 3
- clase lectiva para experiencia 4 parte b
- soporte para copy-on-write en fork
- clase lectiva para experiencia 4 parte c
- comunicacion entre procesos
- clase lectiva para experiencia 5
- filesystem y terminal
- desarrollo de experiencia 5
- entrega de experiencia 5

clase 2

- desarrollo de experiencia 1

- desarrollo de experiencia 1

- desarrollo de experiencia 2

- desarrollo de experiencia 2
- desarrollo de experiencia 2

- desarrollo de experiencia 3

- desarrollo de experiencia 3

- desarrollo de experiencia 3

- desarrollo de experiencia 3

- desarrollo de experiencia 4

- desarrollo de experiencia 4

- desarrollo de experiencia 4

- desarrollo de experiencia 5
- desarrollo de experiencia 5
- evaluaciones tardias

tabla 4.2: schedule para 16 semanas de clases.

universidad tecnica federico santa maria, departamento de informatica

46

capitulo 5. conclusiones

5 | conclusiones

luego de la investigacion previa se logro concretar la construccion de un curso para
el departamento de informatica. el curso proporcionado por massachusetts institute of
technology termino siendo la base para trabajar en este nuevo curso, todo gracias a su libre
disposicion de compartir el curso gracias a los derechos que ellos le otorgaron[27] el cual
permite reutilizacion de codigo mientras exista una referencia de su origen. con ello, se
pudo tomar la informacion de sus laboratorios y se pudo construir un modelo similar y
completo en espanol basado en su sistema operativo xv6 y su kernel jos.

el codigo fue clonado y se le realizaron unas pequenas modicaciones de tal forma que
funcione similar al original, de esta forma por cada nueva experiencia se copien archivos
de una rama nueva en git.

se construyo un plan de trabajo para un curso de 16 semanas en donde es posible la
elaboracion de cinco experiencias mas cinco pruebas que contienen la materia abarcada por
cada una de las experiencias para asi asegurar que los alumnos tienen los conocimientos
posterior a su realizacion, ademas de contar con clases presenciales en las cuales se
introduce la materia para cada uno de los entregables a realizar.

las experiencias construidas para el curso cumplen con el objetivo de que sean evoluti-
vas. se demostro que, mientras que se desarrollan las experiencias 2 y 3 por ejemplo, son
necesarias las funciones creadas en la experiencia 1.

los estudiantes que cursen esta asignatura terminarian capaces de describir cuales son
los bloques basicos que componen un sistema operativo, conocer y explicar a groso modo
como es la administracion de la memoria, saber como funciona un sistema de archivos
simple y tener las nociones basicas de la optimizacion de un sistema operativo como tal,
lo que transforma esta posible asignatura en algo relevante para los alumnos que esten

universidad tecnica federico santa maria, departamento de informatica

47

capitulo 5. conclusiones

interesados en este campo.

ahora tan solo basta formalizar este contenido y plantearlo en un curso real para que
los alumnos puedan alcanzar los conocimientos deseados de la construccion de un sistema
operativo.

universidad tecnica federico santa maria, departamento de informatica

48

bibliografia

bibliografia

bibliografia

[1] anderson, t., and dahlin, m. operating systems: principles and practice. recursive

books, 2012. 3.1.2

[2] carter, p. a. pc assembly language, november 2003. b.1.2

[3] comer, d. operating system design: the xinu approach, second edition. chapman

and hall/crc, 2015. 2.1.7, 3.1.7, ??, 3.3.4

[4] creativecommons. attribution 3.0 united states (cc by 3.0 us).

creativecommons.org/licenses/by/3.0/us/, dec.
2015]. 4

http://
[acceso diciembre de

[5] creativecommons. creative commons atribucion-nocomercial 2.0 chile (cc by-nc 2.0
cl). https://creativecommons.org/licenses/by-nc/2.0/cl/, july. [acceso
julio de 2015]. 2.1.3

[6] creativecommons. cs 161: operating systems. http://www.eecs.harvard.edu/
~margo/cs161/index.html, july. [acceso julio de 2015]. 2.1.4, 2.1.4, 2.1.4, 3.1.4,
a.5

[7] dave eckhardt, dj begos, c. w. c. l. t. c. b. m. m. s. j. z. 15-410, operating system
design and implementation. https://www.cs.cmu.edu/~410/, july. [acceso julio
de 2015]. 2.1.2, 2.1.2, 2.1.2, 3.1.2

[8] david bafumba-lokilo, e. p. d. m. the xinu page. http://www.xinu.cs.purdue.

edu/, oct. [acceso octubre de 2015]. 2.1.7

[9] de inform atica, d. contenidos de asignatura sistemas operativos en utfsm. http:
//wiki.inf.utfsm.cl/index.php?title=sistemas_operativos, july 2012.
[acceso julio de 2015]. 1

[10] de inform atica, d. malla curricular de ingenieria civil en informatica utfsm. [online],

2013. http://www.inf.utfsm.cl/images/mallas/malla-ici.png. 1

[11] duranceau, g. the crocos kernel. http://crocos.sourceforge.net/, july.

[acceso julio de 2015]. 2.2.1, 3.1.8

[12] friesen, b. brans kernel development, a tutorial on writing kernels. http://www.

osdever.net/bkerndev/index.php, july. [acceso julio de 2015]. 2.3.2, 3.1.10

universidad tecnica federico santa maria, departamento de informatica

49

bibliografia

bibliografia

[13] gnu.org. what is the gnu hurd? http://www.gnu.org/software/hurd/s, july

2015. [acceso julio de 2015]. 1

[14] intel.

intel 64 and ia-32 architectures software developers manual. volume 3a:
system programming guide, part 1. [online]. https://pdos.csail.mit.edu/6.
828/2014/readings/ia32/ia32-3a.pdf. b.3.1

[15] kernighan, b. the c programming language. prentice hall, englewood clis, n.j,

1988. b.1.2

[16] kubiatowicz, j. cs194-24: advanced operating systems structures and implemen-
tation. http://www.cs.berkeley.edu/~kubitron/courses/cs194-24-s14/
index_overview.html, july. [acceso julio de 2015]. 2.1.6, 2.1.6, 3.1.6

[17] lewischeng ms. mit-jos.
mit-jos. b, b.2.2, b.2.3

[online]. https://github.com/lewischeng-ms/

[18] lions, j. lions commentary on unix. peer to peer communications/ annabook,

1977. 2.1.1

[19] love, r., are, s. h. w., linus, a. c., kernels, l. v. c. u., and begin, b. w. linux

kernel development second edition. novell press: sams publishing, 2005. 1

[20] mclean, p. t. information technology - at attachment with packet interface - 6

(ata/atapi-6), december 2001. b.1.2

[21] mit. intel 80386 reference programmers manual. [online]. https://pdos.csail.

mit.edu/6.828/2014/readings/i386/toc.htm. b.2.2, b.3.1

[22] mit. 6.828: operating system engineering. http://pdos.csail.mit.edu/6.

828/2014/general.html, july 2014. [acceso julio de 2015]. 2.1.1, 3.1.1, a.1

[23] mit. 6.828: operating system engineering, lab 1: booting a pc. https://pdos.
[acceso diciembre de

csail.mit.edu/6.828/2014/labs/lab1/, dec. 2014.
2015]. b.1

[24] mit. xv6, a simple, unix-like teaching operating system. http://pdos.csail.

mit.edu/6.828/xv6/, july 2014. [acceso julio de 2015]. 2.1.1

[25] molloy, j. jamesms kernel development tutorials. http://www.jamesmolloy.co.

uk/tutorial_html/, july. [acceso julio de 2015]. 2.3.1, 2.3.1, 3.1.9

[26] nakulm95. gitlab nakul (nick) malhotra / 451. [online]. https://gitlab.cs.

washington.edu/nakulm95/jos-15au/tree/lab1. b

[27] (osi), o. s. i. the mit license (mit). http://opensource.org/licenses/

mit-license.php, july. [acceso julio de 2015]. 2.1.1, 5

[28] ramos, m. sistemas operativos monopuesto. ciclos formativos. paraninfo,

2010. 3

universidad tecnica federico santa maria, departamento de informatica

50

bibliografia

bibliografia

[29] russ cox, frans kaashoek, r. m. xv6, a simple, unix-like teaching operating system,

september 2014. 2.1.1, ??

[30] solworth, j. a. cs 486: secure operating system design and implementation. http:
[acceso julio de 2015].

//www.ethos-os.org/~solworth/cs486.html, july.
2.1.5, 2.1.5, 3.1.5

[31] solworth, j. a. the ethos operating system. http://www.ethos-os.org/, july.

[acceso julio de 2015]. 2.1.5, 3.1.5

[32] sumi helal, p. cop 4600: operating systems. http://www.cise.ufl.edu/

~helal/classes/s15/, oct. [acceso octubre de 2015]. 2.1.7, 3.1.7

[33] system, g. o. gnu general public license version 3. http://www.gnu.org/

licenses/gpl-3.0.en.html, july. [acceso julio de 2015]. 2.2.1

[34] ubuntu, c. l. . f. imagen iso centos 7. [online], 2015. http://www.ubuntu.com/.

a.1, a.2, a.3

[35] underwood, b. b. brennans guide to inline assembly. http://www.delorie.com/
djgpp/doc/brennan/brennan_att_inline_djgpp.html, dec. 1996. [acceso
diciembre de 2015]. b.1.1

[36] university, c. m. a.2 cmu license. http://www.gnu.org/software/hurd/

gnumach-doc/cmu-license.html, july. [acceso julio de 2015]. 2.1.2

[37] university, l. s. j. cs 140: operating systems (spring 2014). http://web.
stanford.edu/~ouster/cgi-bin/cs140-spring14/index.php, july. [acce-
so julio de 2015]. 2.1.3, 2.1.3, 2.1.3

[38] university, l. s. j. pintos documentation. http://web.stanford.edu/class/
[acceso julio de 2015]. 2.1.3,

cs140/projects/pintos/pintos.html, july.
3.1.3, a.3

[39] university, p. s. how to install xinu on vmware. [online]. ftp://ftp.cs.purdue.

edu/pub/comer/private/xinu/how-to-install-xinu-on-vmware.pdf.
3.2.4, a.4

[40] wolf, g. fundamentos de sistemas operativos. 3

universidad tecnica federico santa maria, departamento de informatica

51

bibliografia

bibliografia

universidad tecnica federico santa maria, departamento de informatica

52

anexo a. documentacion

a | documentacion

a.1.

instalacion de sistema operativo xv6 para curso de
massachusetts institute of technology

para realizar el procedimiento de prueba del repositorio de trabajo de xv6 del curso, se

utilizo una maquina virtual con sistema operativo ubuntu desktop 15.10[34].

lo primero es la instalacion de las dependencias del sistema. para ello se debe abrir

una terminal con permisos de administrador e ingresar los siguientes comandos:

sudo apt-get -y update

sudo apt-get -y upgrade

sudo apt-get -y update

sudo apt-get install -y git

luego se procede a la instalacion de qemu, el cual virtualizara el sistema operativo

con el que se trabajara.

sudo apt-get install -y qemu-kvm qemu virt-manager virt-viewer libvirt-bin

por ultimo solo basta con clonar el repositorio git de xv6[22], compilar y ejecutar bajo

qemu.

git clone git://github.com/mit-pdos/xv6-public.git

cd xv6-public

make

make qemu

universidad tecnica federico santa maria, departamento de informatica

53

a.2. instalacion de sistema operativo creado en jamesms kernel development tutorials

anexo a. documentacion

en este repositorio se encuentra el proyecto completo luego de realizar las experiencias

que ofrece el curso.

a.2.

instalacion de sistema operativo creado en jamesms
kernel development tutorials

para probar el sistema operativo que se crea durante el tutorial otorgado por jamesm,
es necesario instalar el emulador de este, el cual en este caso es bochs. trabajamos bajo
ubuntu desktop 15.10 x32[34]. para ello procedemos a abrir una terminal con permisos de
administrador y ejecutar los siguientes comandos:

sudo apt-get -y update

sudo apt-get -y upgrade

sudo apt-get -y update

sudo apt-get install -y git

sudo apt-get install -y bochs bochs-x bochs-sdl

luego descargamos el archivo que contiene el codigo generado luego de realizar todo

el tutorial, lo descomprimimos y lo ejecutamos bajo bochs.

wget http://www.jamesmolloy.co.uk/downloads/user_mode.tar.gz

tar -xzvf user_mode.tar.gz

cd src

make clean

make

cd ..

mkdir /mnt2

./update_image.sh

./run_bochs.sh

podemos apreciar los resultados del tutorial hasta el capitulo de user mode.

universidad tecnica federico santa maria, departamento de informatica

54

a.3. instalacion de sistema operativo pintos para curso de standford university

anexo a. documentacion

a.3.

instalacion de sistema operativo pintos para curso
de standford university

toda la insformacion del sistema operativo pintos se encuentra en su pagina ocial[38]
junto con su repositorio con el codigo para realizar las experiencias que ofrece el curso.
para ello necesitamos una maquina virtual x32, que en nuestro caso utilizaremos ubuntu
desktop 15.10 x32[34]. en ella ejecutamos los comandos de actualizacion e instalacion
de dependencias. pintos funciona tanto para ser utilizado con bochs como por qemu.
instalaremos ambas en esta ocasion.

sudo apt-get -y update

sudo apt-get -y upgrade

sudo apt-get -y update

sudo apt-get install -y git

sudo apt-get install -y bochs bochs-x bochs-sdl

sudo apt-get install -y qemu-kvm qemu virt-manager virt-viewer libvirt-bin

luego descargamos el archivo comprimido con el codigo de pintos.

wget http://www.stanford.edu/class/cs140/projects/pintos/pintos.tar.gz

tar -xzvf pintos.tar.gz

cd pintos/src

aqui nos encontramos con varias carpetas las cuales separan por cada una de las
experiencias a realizar. tener en cuenta que este codigo se encuentra incompleto ya que
esta preparado para ser modicado.

antes que todo, es necesario copiar las aplicaciones que sirven para realizar la compila-
cion de los kernels. para ello copiamos todos los archivos que se encuentran dentro de la
carpeta utils en la carpeta /bin.

scp -r utils/* /bin

universidad tecnica federico santa maria, departamento de informatica

55

a.4. instalacion de sistema operativo xinu para curso de university of florida

anexo a. documentacion

asi contamos con el script llamado pintos que nos permitira ejecutar las maquinas

simuladas.

por ultimo, podemos realizar las pruebas necesarias para cada experiencia ya que
se encuentran separadas en carpetas. por ejemplo, si deseamos probar el codigo para la
experiencia 1 de threads sera necesario realizar lo siguiente:

cd threads

make

pintos run alarm-multiple

continue

vemos como un script de prueba se ejecuta en la experiencia a realizar.

a.4.

instalacion de sistema operativo xinu para curso de
university of florida

xinu es posible ser ejecutado bajo vmware gracias a que el mismo sistema ofrece
maquinas virtuales pre-armadas. con esta informacion procedemos a descargar dichas
maquinas virtuales de la direccion:

ftp://ftp.cs.purdue.edu/pub/comer/private/xinu/xinu-vm.tar.gz

luego, se descomprimen los archivos y se continuan los pasos tal como se muestra en

el manual adjunto al archivo de descarga[39].

primero se importan ambas maquinas virtuales a vmware, xinu-vclient y xinu-vserver,

luego se procede a congurar las conexiones de red.

en xinu-vserver:

1. entrar a las conguraciones de la maquina (click derecho>settings)

2. seleccionar la primera tarjeta de red, luego colocar la opcion custom: specic virtual

network y seleccionar vmnet9

universidad tecnica federico santa maria, departamento de informatica

56

a.4. instalacion de sistema operativo xinu para curso de university of florida

anexo a. documentacion

3. seleccionar la segunda tarjeta de red, para ella escogemos nat: used to share the

hosts ip address.

4. seleccionar ok para guardar los cambios.

en xinu-vclient:

1. entrar a las conguraciones de la maquina (click derecho>settings)

2. seleccionar la primera tarjeta de red, luego colocar la opcion custom: specic virtual

network y seleccionar vmnet9 (escogiendo la misma que la del servidor)

3. seleccionar ok para guardar los cambios.

con esto ya tenemos conexion por red, ahora la conguramos para tener comunicacion

via puerto serial.

en xinu-vserver:

1. entrar a las conguraciones de la maquina (click derecho>settings).

2. click en add.

3. seleccionar serial port y luego next.

4. seleccionar output to named pipe y luego next.

5. colocar un nombre para la comunicacion, este debe comenzar con \\.\pipe\, seleccio-
nar this end is the server, the other end is a virtual machine y connect at power
on.

6. click en finish para nalizar.

en xinu-vclient:

1. entrar a las conguraciones de la maquina (click derecho>settings).

2. click en add.

3. seleccionar serial port y luego next.

universidad tecnica federico santa maria, departamento de informatica

57

a.4. instalacion de sistema operativo xinu para curso de university of florida

anexo a. documentacion

4. seleccionar output to named pipe y luego next.

5. colocar un nombre para la comunicacion, este debe ser el mismo ingresado ante-
riormente, seleccionar this end is the client, the other end is a virtual machine y
connect at power on.

6. click en finish.

7. en las conguraciones del nuevo puerto serial se debe activar la opcion de yield

cpu on poll.

finalmente nos queda correr las maquinas virtuales, lo haremos de la siguiente manera:

1. encender xinu-vserver e ingresar con los datos:

user: xinu

pass: xinurocks

2. nos encontraremos con un archivo llamado xinu-x86-vm.tar.gz en la raiz, lo descom-

primimos con:

tar -xzvf xinu-x86-vm.tar.gz

3. ingresamos a la carpeta y nos posicionamos dentro de compile.

cd xinu-x86-vm/compile

4. compilamos y lo dejamos como ejecutable.

make clean

make

cp xinu /srv/tftp

5. ejecutamos minicom

sudo minicom

6. finalmente ejecutamos la maquina virtual xinu-vclient, con ello obtenemos corriendo

sin problemas xinu en la terminal de minicom.

universidad tecnica federico santa maria, departamento de informatica

58

a.5. instalacion de sistema operativo cs 161 para el curso cs 161: operating systems de harvard
university

anexo a. documentacion

a.5.

instalacion de sistema operativo cs 161 para el cur-
so cs 161: operating systems de harvard univer-
sity

el curso otorga una maquina virtual base para realizar todo el trabajo que se necesita
por delante. la maquina cuenta con ubuntu 14.04.1 lts y viene con las herramientas ya
puestas en su lugar, esto incluye editores de texto, aplicaciones de compilacion, aplicaciones
de virtualizacion, control de versiones, sistemas de debug y mas. funciona bajo vmware y
es posible descargar aca:

http://www.eecs.harvard.edu/~margo/cs161/appliance161-2015.ova

luego de tener la maquina virtual descargada, es necesario realizar la importacion en

vmware para luego proceder a encender.

en ella nos queda descargar el proyecto para comenzar a desarrollar las experiencias
dadas por el curso, por lo que, en la maquina virtual, ingresamos a una terminal e ingresamos
la siguiente linea de comando:

git clone git://code.seas.harvard.edu/cs161/os161.git

con esto ya podemos trabajar en las actividades segun se indican en la pagina web del
curso[6]. finalmente, para probar que la tarea fue correctamente realizada, es necesario
realizar los siguientes pasos:

1. posicionarse en la base del repositorio git clonado y ejecutar los siguientes comandos
para realizar las compilaciones necesarias (con asstn la experiencia que se esta
realizando):

mkdir ~/tmp/root

./configure --ostree=$home/tmp/root

bmake

bmake install

universidad tecnica federico santa maria, departamento de informatica

59

a.6. instalacion de sistema operativo creado en bran kernel tutorial anexo a. documentacion

cd kern/config

./config asstn

cd ../compile/asstn

bmake depend

bmake

bmake install

2. luego de tener todo compilado, nos posicionamos en la raiz del kernel que dejamos

en \tmp\root, copiamos el archivo de conguracion y ejecutamos el sistema.

cd ~/tmp/root

cp ~/cs161/sys161/sys161-2.0.2/sys161.conf.sample sys161.conf

sys161 kernel "tt1"

3. ejecutar los comandos de prueba segun la experiencia a necesitar.

a.6.

instalacion de sistema operativo creado en bran ker-
nel tutorial

el proceso de ejecucion de este sistema operativo es bastante similar al aplicado para
ejecutar el de tutorial de jamesm en la seccion a.2 con unas pequenas diferencias que
haremos notar. cabe destacar que se utiliza la misma maquina virtual utilizada en la seccion
a.2 por lo que se encuentran los archivos de este.

1. lo primero que debemos hacer es descargar el codigo y descomprimir los archivos.

wget http://www.osdever.net/bkerndev/bkerndev.zip

unzip bkerndev.zip

2. nos posicionamos en el tutorial de james y copiamos los archivos bochsrc.txt y

run_bochs.sh dentro de la carpeta bkerndev/source recien descomprimida.

3. nos posicionamos en la carpeta bkerndev/source y ejecutamos:

universidad tecnica federico santa maria, departamento de informatica

60

a.6. instalacion de sistema operativo creado en bran kernel tutorial anexo a. documentacion

sh build.bat

ignorar los errores.

4. clonar y renombrar el archivo dev_kernel_grub.img a oppy.img.

cp dev_kernel_grub.img floppy.img

5. finalmente ejecutamos el script run_bochs.sh

sh run_bochs.sh

con esto vemos el kernel simplista creado durante este tutorial.

universidad tecnica federico santa maria, departamento de informatica

61

a.6. instalacion de sistema operativo creado en bran kernel tutorial anexo a. documentacion

universidad tecnica federico santa maria, departamento de informatica

62

anexo b. desarrollo de curso ofrecido por mit

b | desarrollo de curso ofrecido por

mit

el objetivo principal es el desarrollo de las primeras 5 experiencias, las cuales en el
orden dado conllevan a un trabajo incremental. para poder ejecutar el emulador qemu es
necesario ya haber pasado por las explicaciones dadas en la documentacion del anexo a.1.
los codigos fueron basados por trabajos ya realizados por alumnos que ya cursaron el

curso y fueron vericados para el desarrollo de este trabajo[17][26].

b.1. lab 1: booting a pc

el primer laboratorio se separa en tres partes, la primera consta de familiarizarse con el
lenguaje assembly, el emulador qemu x86 y el procedimiento de prendido y booteo de un
pc. la segunda parte se encarga de analizar el codigo de carga del kernel 6.828 el cual se
encuentra en la carpeta boot en los archivos del laboratorio. finalmente, la tercera parte
analiza el template inicial del kernel 6.828 el cual lo llamaremos jos, el cual reside en el
directorio kernel[23].

el laboratorio en cuestion se encuentra en un repositorio git publico el cual es posible

ser clonado con el comando:

git clone https://pdos.csail.mit.edu/6.828/2014/jos.git lab

los distintos laboratorios se encuentran en ramas (branch) del repositorio git, tan solo
basta con revisar cuales ramas contiene para luego saltar a la otra. tener en cuenta que al

universidad tecnica federico santa maria, departamento de informatica

63

b.1. lab 1: booting a pc

anexo b. desarrollo de curso ofrecido por mit

momento de pasar de un laboratorio a otro, es necesario mezclar el trabajo realizado al
nuevo laboratorio antes de proceder con su elaboracion.

git checkout -b lab2 origin/lab2

git merge lab1

en cualquier momento de la realizacion de la experiencia de laboratorio, es posible
ejecutar un comando que evalua si el trabajo realizado es correcto; dicho comando se debe
ejecutar en la raiz y corresponde a:

make grade

el cual nos representara lo que esta correcto y lo que no, junto con una nota entre 0 y

100.

b.1.1. part 1: pc bootstrap

el principal objetivo de esta primera parte es familiarizarnos con las herramientas que
utilizaremos durante el curso. para acercarnos a assembly, se recomienda solo leer al
respecto[35], sin causar impacto en el kernel en construccion, ya que en ningun momento
del curso se programara en dicho lenguaje, pero es importante conocer que es lo que esta
haciendo.

luego se presenta qemu como la aplicacion que emula por completo un pc, con la
ventaja de que es posible analizar el procedimiento de este con programas de debuggueo.
para utilizar qemu en el proyecto es necesario posicionarse en la raiz y ejecutar:

make

make qemu

lo que nos abrira la aplicacion con el sistema base que trae el laboratorio. claramente

no trae muchas cosas ya que uno es el que debe ir agregandole caracteristicas.

tener en cuenta que al momento de ejecutar el comando make, se genera un archivo
en el directorio obj/kernel llamado kernel.img, el cual si lo ponemos en un dispositivo de
memoria, es posible ejecutarlo en un computador real, pero no es recomendable porque

universidad tecnica federico santa maria, departamento de informatica

64

b.1. lab 1: booting a pc

anexo b. desarrollo de curso ofrecido por mit

puede causar conictos con el sistema de booteo que posea actualmente dicho computador,
provocando que este sea reemplazado por el que estamos probando, pudiendo causar
problemas tan graves como la perdida de toda la informacion.

finalmente se realiza la introduccion del sistema de debuggueo llamado gdb, este
viene precongurado para que sea posible su utilizacion enlazada con qemu para poder
ir revisando en vivo lo que sucede en nuestro kernel. para ello es necesario realizar los
siguientes pasos:

1. lo primero es compilar el codigo que llevamos actualmente, tan solo es necesario

ejecutar el comando

make

2. luego debemos ejecutar lo compilado, con la diferencia de que ahora utilizaremos el

comando

make qemu-gdb

veremos una pantalla de qemu en negro pausada.

3. abrimos una nueva terminal, nos posicionamos en la carpeta raiz del usuario y

creamos un archivo llamado .gdbinit con el siguiente contenido:

add-auto-load-safe-path /*usuario*/lab/.gdbinit

debemos indicar la direccion en donde se encuentra el archivo .gdbinit ubucado en
la raiz de la carpeta del laboratorio.

4. nos posicionamos en la raiz del laboratorio y ejecutamos el comando

gdb

con esto es posible evaluar los lugares en donde los punteros estan direccionados en la
memoria para la ejecucion inicial de booteo del sistema operativo. como ejercicio se pide
ejecutar comandos en dicha nueva terminal para analizar lo sucedido segun lo explicado en
las mismas indicaciones con respecto a las direcciones fisicas del computador.

universidad tecnica federico santa maria, departamento de informatica

65

b.1. lab 1: booting a pc

anexo b. desarrollo de curso ofrecido por mit

b.1.2. part 2: the boot loader

es una introduccion a la estructura de boot que se utiliza en el arranque de un sistema
operativo. para la experiencia, el sistema de booteo se encuentra programado en lenguaje
assembly y c en los archivos boot/boot.s y boot/main.c respectivamente, con ello, el primer
ejercicio es tratar de conocer que es lo que esta sucediendo en estos dos archivos, el material
cuenta con lecturas especializadas para esta etapa[2][20].

luego de comprender estos archivos podemos analizar el archivo ya compilado que se
creo luego de la primera prueba realizada; el archivo llamado obj/boot/boot.asm contiene las
instrucciones de memoria indicadas en los dos archivos. el codigo se encuentra comentado
para facilitar su identicacion de sus lineas. una de las cosas muy claras que podemos
apreciar es la conguracion de los modos privados y reales ademas de los saltos de memoria
que se utilizan al arranque del sistema.

de la misma manera podemos ver como quedo compilado el kernel jos analizando el
archivo obj/kern/kernel.asm, esto nos sirve para el proceso de debug. por ejemplo, podemos
indicar en que direccion de memoria el kernel pause su ejecucion hasta que se le indique lo
contrario, de esta forma analizar lo que se ejecuta por partes. con esto aparece un nuevo
ejercicio en el cual se solicita realizar pausas al sistema en la direccion 0x7c00 y con
ello indicar en que parte del codigo de boot/boot.s corresponde dicha parte. ademas de
familiarizarse mas con la terminal de gdb.

por otro lado tenemos el codigo en lenguaje c del archivo boot/main.c el cual lo
podemos comprender con conocimientos basicos de punteros. el curso recomienda el libro
the c programming language[15] desde el capitulo 5.1 hasta 5.5. con ello, se pide analizar
para que son los primeros punteros encontrados en las lineas 1 a 6.

posteriormente se indica la estructura de un archivo binario de formato elf, como
enfasis solo se da a notar, para centrarnos en el curso, que se considerara como un archivo
que contiene el codigo necesario para cargar informacion inicial. para los archivos en
lenguaje c esta informacion es incluida gracias a la linea de codigo que incluye el header
inc/elf.h. si analizamos el archivo, vemos como se instancializan las variables globales para
el sistema. para examinar la lista entera de nombres de variables de la cabecera, tamanos y

universidad tecnica federico santa maria, departamento de informatica

66

b.1. lab 1: booting a pc

anexo b. desarrollo de curso ofrecido por mit

direcciones de las direcciones en el kernel, es posible ejecutar cualquiera de estas lineas de
comando:

i386-jos-elf-objdump -h obj/kern/kernel

objdump -h obj/kern/kernel

en donde podemos observar:

obj/kern/kernel:

formato del fichero elf32-i386

secciones:

ind nombre

tamano

vma

lma

desp fich alin

0 .text

00001861

f0700000

00100000

00001000

2**4

contents, alloc, load, readonly, code

1 .rodata

00000730

f0101880

00101880

00002880

2**5

contents, alloc, load, readonly, data

2 .stab

000038b9

f0101fb0

00101fb0

00002fb0

2**2

contents, alloc, load, readonly, data

3 .stabstr

000018c9

f0105869

00105869

00006869

2**0

contents, alloc, load, readonly, data

4 .data

0000a300

f0108000

00108000

00009000

2**12

contents, alloc, load, data

5 .bss

00000644

f0112300

00112300

00013300

2**5

alloc

6 .comment

0000002d

00000000

00000000

00013300

2**0

contents, readonly

podemos obtener mas informacion si el proceso objdump le cambiamos la indicacion
por -x, con la cual nos muestra con mas detalle las funciones que utiliza y en que posicion
de la memoria estan guardadas. tambien tenemos -f el cual solo nos muestra el tipo de
arquitectura y la direccion de memoria que corresponde a su inicio.

universidad tecnica federico santa maria, departamento de informatica

67

b.1. lab 1: booting a pc

anexo b. desarrollo de curso ofrecido por mit

finalmente esta parte queda con un ejercicio de gdb, el cual consiste en analizar 8
palabras de memoria cuando inicializa la bios y cuando inicializa el kernel y comparar sus
resultados.

b.1.3. part 3: the kernel

parte del laboratorio en donde se escribe codigo en lenguaje c, se basa en la modica-
cion del sistema de arranque del kernel, iniciando por su posicionamiento en la memoria.
lo primero es mapear los primeros 4 mb de la memoria fisica, la que es suciente para
ejecutar el arranque. para ello se utiliza un directorio y tablas estaticas ubicadas en el
archivo kern/entrypgdir.c. por ahora solo basta con entender que es lo que hace, debemos
entender que el archivo kern/entry.s traspasa esta tabla a memoria virtual para luego ser
transformada en direcciones de memoria fisicas. con ello, el laboratorio realiza un ejercicio
el cual consiste en ejecutar gdb en el sistema operativo y parar cada vez que se ejecute
la linea movl %eax, %cr0 y analizar en que posicion de la memoria fisica se encuentra
ejecutando.

luego pasamos a la edicion del codigo. como primera tarea se pide modicar la
funcionalidad de printf para que le sea posible imprimir por pantalla numeros octales;
para ello se requiere analizar los archivos kern/printf.c, lib/printfmt.c y kern/console.c para
realizar los cambios correspondientes. el codigo a cambiar se encuentra documentado en
lib/printfmt.c y se cuenta con una aplicacion que verica si el procedimiento realizado se
encuentra correctamente. el codigo a agregar es:

case o:

num = getuint(&ap, lflag);

base = 8;

goto number;

el ejercicio nal del laboratorio trata sobre la pila (stack). vemos la forma en como
el codigo escrito en lenguaje c contempla el manejo completo de una pila x86. el primer
ejercicio es encontrar entre todo el codigo el lugar en donde la pila se inicializa, esto es

universidad tecnica federico santa maria, departamento de informatica

68

b.1. lab 1: booting a pc

anexo b. desarrollo de curso ofrecido por mit

el punto exacto de la memoria en que es convocada, como el kernel reserva su espacio y
como naliza este espacio.

se da bastante enfasis en trabajar con las direcciones otorgadas por eip y ebp las cuales
son el puntero base y el puntero de la pila. se pide programar en lenguaje c una forma de
leer la pila y mostrar sus direcciones por pantalla de la forma:

stack backtrace:

ebp f0109e58

eip f0100a62

args 00000001 f0109e80 f0109e98 f01...

ebp f0109ed8

eip f01000d6

args 00000000 00000000 f0100058 f01...

...

para ello se edita el archivo kern/monitor.c en la funcion mon_backtrace() con lo

siguiente:

int mon_backtrace(int argc, char **argv, struct trapframe *tf)

{

uint32_t ebp = read_ebp(), *ebpp, eip, i;

struct eipdebuginfo dbg;

while (ebp > 0) {

ebpp = (uint32_t *)ebp;

eip = ebpp[1];

cprintf("ebp %x eip %x args", ebp, eip);

for (i = 2; i < 6; i++) {

cprintf(" %08x", ebpp[i]);

}

debuginfo_eip(eip, &dbg);

cprintf("\n\t%s:%d: ", dbg.eip_file, dbg.eip_line);

for (i = 0; i < dbg.eip_fn_namelen; i++)

cputchar(dbg.eip_fn_name[i]);

cprintf("+%d\n", eip - dbg.eip_fn_addr);

ebp = *ebpp;

}

universidad tecnica federico santa maria, departamento de informatica

69

b.2. lab 2: memory management

anexo b. desarrollo de curso ofrecido por mit

return 0;

}

luego, para los ejercicios siguientes, es necesario registrar esta funcion para que sea
posible ejecutar desde jos. para ello editamos el archivo kern/kdebug.c y activamos la
funcion stab_binsearch() agregandola en la linea 204 el siguiente codigo:

stab_binsearch(stabs, &lline, &rline, n_sline, addr);

if (lline > rline)

return -1;

info->eip_line = stabs[lline].n_desc;

y por ultimo agregamos el comando al monitor editando nuevamente el archivo ker-
n/monitor.c pero ahora agregamos un elemento a la estructura inicial commands[] con la
siguiente linea:

{ "backtrace", "display backtrace", mon_backtrace },

con esto, desde nuestro sistema operativo podemos ver las aplicaciones que se encuen-

tran actualmente en la pila.

para nalizar, es importante realizar el comando make grade para vericar que todo
se encuentra en orden. en caso de problemas entonces hay que revisar si el codigo se esta
ejecutando correctamente.

b.2. lab 2: memory management

el objetivo principal de este laboratorio es la construccion completa de la gestion de
memoria. esta se separa en dos principales componentes: la memoria fisica y la memoria
virtual. la memoria fisica es asignada por el kernel el cual la puede asignar o liberar segun
corresponda, para ello se utilizan unidades de 4096 bytes llamadas paginas. la memoria
virtual por otro lado mapea las direcciones usadas por el kernel y el sotware del usuario
en la memoria fisica.

para trabajar en este laboratorio, es necesario realizar unos cambios en el repositorio

git.

universidad tecnica federico santa maria, departamento de informatica

70

b.2. lab 2: memory management

anexo b. desarrollo de curso ofrecido por mit

git add kern/kdebug.c kern/monitor.c lib/printfmt.c

git commit -m "termino lab 1"

git checkout -b lab2 origin/lab2

git merge lab1

b.2.1. part 1: physical page management

es necesario conocer cuales son las partes libres y ocupadas fisicas de la memoria

ram. en jos se utiliza mmu para tener el registro de mapeo de las paginas.

se pide modicar el archivo kern/pmap.c para escribir el sistema mmu. en ella
se deben modicar las funciones boot_alloc(), mem_init(), page_init(), page_alloc() y
page_free(). luego de tenerlas implementadas, es posible probarlas con las funciones
check_page_free_list() y check_page_alloc(). no hay mucha explicacion de como se debe
desarrollar todo, lo que es parte del objetivo del ejercicio. las respuestas son:

static void * boot_alloc(uint32_t n)

{

static char *nextfree;

char *result;

if (!nextfree) {

extern char end[];

nextfree = roundup((char *) end, pgsize);

}

if (n > 0) {

uint32_t alloc_size = roundup(n, pgsize);

result = nextfree;

nextfree += alloc_size;

if ((uintptr_t)nextfree >= 0xf0400000)

panic("boot_alloc: out of memory");

} else {

universidad tecnica federico santa maria, departamento de informatica

71

b.2. lab 2: memory management

anexo b. desarrollo de curso ofrecido por mit

result = nextfree;

}

return result;

}

void mem_init(void)

{

uint32_t cr0;

size_t n;

i386_detect_memory();

kern_pgdir = (pde_t *) boot_alloc(pgsize);

memset(kern_pgdir, 0, pgsize);

kern_pgdir[pdx(uvpt)] = paddr(kern_pgdir) | pte_u | pte_p;

page_init();

check_page_free_list(1);

check_page_alloc();

check_page();

boot_map_region(kern_pgdir, upages, ptsize, paddr(pages), pte_u);

boot_map_region(kern_pgdir, kstacktop - kstksize, kstksize,

paddr(bootstack), pte_w);

boot_map_region(kern_pgdir, kernbase, -kernbase/* ~kernbase + 1

*/, 0, pte_w);

check_kern_pgdir();

lcr3(paddr(kern_pgdir));

check_page_free_list(0);

cr0 = rcr0();

cr0 |= cr0_pe|cr0_pg|cr0_am|cr0_wp|cr0_ne|cr0_mp;

universidad tecnica federico santa maria, departamento de informatica

72

b.2. lab 2: memory management

anexo b. desarrollo de curso ofrecido por mit

cr0 &= ~(cr0_ts|cr0_em);

lcr0(cr0);

check_page_installed_pgdir();

}

void page_init(void)

{

size_t i;

page_free_list = null;

for (i = 0; i < npages; i++) {

if (i == 0 || !inmapavail(&pages[i]) || isiniohole(&pages[i])) {

pages[i].pp_ref = 1;

pages[i].pp_link = null;

} else {

pages[i].pp_ref = 0;

pages[i].pp_link = page_free_list;

page_free_list = &pages[i];

}

}

}

struct page * page_alloc(int alloc_flags)

{

struct page *result = page_free_list;

if (!result)

return null;

page_free_list = result->pp_link;

universidad tecnica federico santa maria, departamento de informatica

73

b.2. lab 2: memory management

anexo b. desarrollo de curso ofrecido por mit

if (alloc_flags & alloc_zero) {

char *kva = page2kva(result);

memset(kva, \0, pgsize);

}

return result;

}

void page_free(struct page *pp)

{

}

assert(pp);

assert(pp->pp_ref == 0);

pp->pp_link = page_free_list;

page_free_list = pp;

b.2.2. part 2: virtual memory

para esta parte es necesario realizar ciertas lecturas en el manual de intel 80386[21], mas
especico los capitulos 5 y 6 para familiarizarse con el modo protegido de la arquitectura
de manejo de memoria (segmentacion y traduccion de paginas).

luego, como ejercicio se pide utilizar gdb para inspeccionar el emulador qemu y
sus direcciones virtuales. para ello se pueden utilizar comandos especiales para que gdb
nos retorne dichas direcciones.

1. en qemu, es posible ingresar la secuencia de botones ctrl-a c para acceder al

monitor de este.

2. en el monitor de qemu se puede utilizar el comando xp y en gdb el comando x
para inspeccionar la memoria y asi identicar cual es memoria fisica y cual virtual.
(recomendable vericar en ambos lugares para vericar que es la misma informacion)

universidad tecnica federico santa maria, departamento de informatica

74

b.2. lab 2: memory management

anexo b. desarrollo de curso ofrecido por mit

3. en el monitor de qemu puede que se encuentre el comando info pg el cual muestra
una tabla con las paginas actuales, incluyendo rangos de memoria mapeados, permi-
sos y banderas. tambien se encuentra el comando info mem para saber que rangos
de la memoria virtual estan mapeados y con que permisos. que se encuentren estos
comandos depende de la version de qemu.

despues nos hacen una pregunta:

c type

t*

uintptr_t
physaddr_t

addres type

virtual
virtual
physical

tabla b.1: tabla para ejercicio laboratorio 2 parte 2.

assuming that the following jos kernel code is correct, what type should variable x

have, uintptr_t or physaddr_t?

mystery_t x;

char* value = return_a_pointer();

*value = 10;

x = (mystery_t) value;

r: la variable x corresponde a un uintptr_t debido a que se utiliza la referencia de un
puntero para que sea asignado a la variable. en caso de que x sea physaddr_t entonces
este puede tomar la direccion de memoria correspondiente pero no le es posible realizar
modicaciones en caso de que esta se encuentre en la memoria virtual. el kernel diferencia
las direcciones de memoria sumando o restando respectivamente 0xf0000000. para memoria
fisica a memoria virtual debe sumar esa cantidad, para realizar el proceso inverso entonces
se resta.

como ultimo ejercico de este tema se pide implementar en el archivo kern/pmap.c las
funciones pgdir_walk(), boot_map_region(), page_lookup(), page_remove() y page_insert().
dicho codigo corresponde al siguiente [17]:

pte_t * pgdir_walk(pde_t *pgdir, const void *va, int create)

universidad tecnica federico santa maria, departamento de informatica

75

b.2. lab 2: memory management

anexo b. desarrollo de curso ofrecido por mit

{

pte_t *vaddr;

pte_t *pgtb;

pde_t pde;

struct page *temp;

pde=pgdir[pdx(va)];

if(pde&pte_p)

{

}

pgtb=(pte_t *)pte_addr(pde);

vaddr=kaddr((physaddr_t)(pgtb+ptx(va)));

return vaddr;

if(!create)

{

}

return null;

else

{

if(page_alloc(&temp))

return null;

{

}

}

pgtb=(pte_t *)page2pa(temp);

pde=(physaddr_t)pgtb|pte_w|pte_p;

pgdir[pdx(va)]=pde;

memset(page2kva(temp), 0, pgsize);

temp->pp_ref =1;

vaddr=kaddr((physaddr_t)(pgtb+ptx(va)));

return vaddr;

universidad tecnica federico santa maria, departamento de informatica

76

b.2. lab 2: memory management

anexo b. desarrollo de curso ofrecido por mit

}

static void boot_map_region(pde_t *pgdir, uintptr_t va,

size_t size, physaddr_t pa, int perm)

{

assert(pgdir);

assert(rounddown(va, pgsize) == va);

assert(rounddown(size, pgsize) == size);

assert(rounddown(pa, pgsize) == pa);

while (size >= pgsize) {

pte_t *pte = pgdir_walk(pgdir, (void *)va, 1);

*pte = pa | perm | pte_p;

va += pgsize;

pa += pgsize;

size -= pgsize;

}

}

struct page * page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)

{

pte_t *pte;

pte=pgdir_walk(pgdir, va, 0);

if((!pte) || !pte_store || (!*pte))

{

}

return null;

else

{

}

*pte_store=pte;

return pa2page(pte_addr(**pte_store));

universidad tecnica federico santa maria, departamento de informatica

77

b.2. lab 2: memory management

anexo b. desarrollo de curso ofrecido por mit

}

void page_remove(pde_t *pgdir, void *va)

{

}

assert(pgdir);

pte_t *pte;

struct page *page = page_lookup(pgdir, va, &pte);

if (!pte || !(*pte & pte_p))

return;

page_decref(page);

*pte = 0;

tlb_invalidate(pgdir, va);

int page_insert(pde_t *pgdir, struct pageinfo *pp, void *va, int perm)

{

assert(pgdir);

assert(pp);

pte_t *pte = pgdir_walk(pgdir, va, 1);

if (!pte)

return -e_no_mem;

physaddr_t pa = page2pa(pp);

if (*pte & pte_p) {

if (pte_addr(*pte) == pa)

goto success;

page_remove(pgdir, va);

}

pp->pp_ref++;

tlb_invalidate(pgdir, va);

success:

*pte = pa | perm | pte_p;

universidad tecnica federico santa maria, departamento de informatica

78

b.2. lab 2: memory management

anexo b. desarrollo de curso ofrecido por mit

return 0;

}

las funciones pueden ser probadas ejecutando ./grade-lab2 o utilizando la informacion

adquirida anterior a estos codigos.

b.2.3. part 3: kernel address space

en esta parte se centra especicamente en la memoria que es utilizada por el kernel, la
que es denida por la variable ulim en el archivo inc/memlayout.h la cual actualmente
reserva 256 mb de la memoria virtual.

el usuario solo puede usar la memoria disponible fuera del rango utilizado por el kernel,
es decir este solo tiene acceso a lectura a dicha memoria. se es necesario iniciar el espacio
especial del kernel para que todo funcione correctamente. para ello es necesario nuevamente
editar el archivo kern/pmap.c y completar la funcion mem_init(). dicha funcion debe quedar
de la siguiente manera [17]:

void mem_init(void)

{

uint32_t cr0;

size_t n;

i386_detect_memory();

kern_pgdir = (pde_t *) boot_alloc(pgsize);

memset(kern_pgdir, 0, pgsize);

kern_pgdir[pdx(uvpt)] = paddr(kern_pgdir) | pte_u | pte_p;

pages = (struct page *)boot_alloc(npages * sizeof(struct page));

page_init();

check_page_free_list(1);

check_page_alloc();

check_page();

boot_map_region(kern_pgdir, upages, ptsize, paddr(pages), pte_u);

boot_map_region(kern_pgdir, kstacktop - kstksize, kstksize,

universidad tecnica federico santa maria, departamento de informatica

79

b.3. lab 3: user environments

anexo b. desarrollo de curso ofrecido por mit

paddr(bootstack), pte_w);

boot_map_region(kern_pgdir, kernbase, -kernbase, 0, pte_w);

mem_init_mp();

check_kern_pgdir();

lcr3(paddr(kern_pgdir));

check_page_free_list(0);

cr0 = rcr0();

cr0 |= cr0_pe|cr0_pg|cr0_am|cr0_wp|cr0_ne|cr0_mp;

cr0 &= ~(cr0_ts|cr0_em);

lcr0(cr0);

check_page_installed_pgdir();

}

finalmente se pide responder a las preguntas planteadas, las cuales resumen todo el

proceso realizado durante esta experiencia.

b.3. lab 3: user environments

el objetivo de la experiencia es crear el ambiente para un sistema protegido de modo
usuario que corra sin problemas. lo ideal es que se active un unico modo usuario, se
carguen programas en el y se ejecuten, con tal de que estos funcionen solo en su espacio y
que se manejen con cuidado cada llamada al sistema necesario para estos.

para la experiencia 3 es necesario agregar los archivos correspondientes. en este trabajo

los comandos para ello son los siguientes:

git checkout -b lab3 origin/lab3

git merge lab2

se adjuntan mas de 20 archivos nuevos al proyecto.

universidad tecnica federico santa maria, departamento de informatica

80

b.3. lab 3: user environments

anexo b. desarrollo de curso ofrecido por mit

b.3.1. part a: user environments and exception handling

lo primero es aprender sobre las nuevas estructuras que se presentan para trabajar. para
ello se de a conocer sobre la cantidad de ambientes que se pueden construir, la cual esta
denida por el numero nenv que se encuentra en el archivo inc/env.h y su enlace con las
variables envs, curenv y env_free_list.

se da a conocer tambien la estructura env con todos sus detalles, la cual se debe ocupar

para los ejercicios siguientes.

el primer ejercicio es modicar nuevamente la funcion mem_init() para colocar y

mapear los arreglos de env. con lo que la funcion nos quedara como:

void mem_init(void)

{

uint32_t cr0;

size_t n;

i386_detect_memory();

kern_pgdir = (pde_t *) boot_alloc(pgsize);

memset(kern_pgdir, 0, pgsize);

kern_pgdir[pdx(uvpt)] = paddr(kern_pgdir) | pte_u | pte_p;

pages = (struct page *)boot_alloc(npages * sizeof(struct page));

envs = (struct env *)boot_alloc(nenv * sizeof(struct env));

page_init();

check_page_free_list(1);

check_page_alloc();

check_page();

boot_map_region(kern_pgdir, upages, ptsize, paddr(pages), pte_u);

boot_map_region(kern_pgdir, uenvs, ptsize, paddr(envs), pte_u);

boot_map_region(kern_pgdir, kstacktop - kstksize, kstksize,

paddr(bootstack), pte_w);

boot_map_region(kern_pgdir, kernbase, -kernbase, 0, pte_w);

mem_init_mp();

universidad tecnica federico santa maria, departamento de informatica

81

b.3. lab 3: user environments

anexo b. desarrollo de curso ofrecido por mit

check_kern_pgdir();

lcr3(paddr(kern_pgdir));

check_page_free_list(0);

cr0 = rcr0();

cr0 |= cr0_pe|cr0_pg|cr0_am|cr0_wp|cr0_ne|cr0_mp;

cr0 &= ~(cr0_ts|cr0_em);

lcr0(cr0);

check_page_installed_pgdir();

}

luego de que son mapeados en la memoria, es necesario trabajar en las funciones
de los ambientes del modo usuario. para ello y como ejercicio 2 se pide modicar en
archivo kern/env.c para completar las funciones env_init(), env_setup_vm(), region_alloc(),
load_icode(), env_create() y env_run() en ese orden, lo que quedaria como:

void env_init(void)

{

int i;

for (i = 0; i != nenv - 1; ++i) {

envs[i].env_id = 0;

envs[i].env_link = &envs[i + 1];

}

envs[nenv - 1].env_link = null;

env_free_list = &envs[0];

env_init_percpu();

}

static int env_setup_vm(struct env *e)

{

int i;

struct page *p = null;

if (!(p = page_alloc(alloc_zero)))

universidad tecnica federico santa maria, departamento de informatica

82

b.3. lab 3: user environments

anexo b. desarrollo de curso ofrecido por mit

return -e_no_mem;

e->env_pgdir = page2kva(p);

for (i = 0; i != pdx(utop); ++i)

e->env_pgdir[i] = 0;

for (; i != npdentries; ++i)

e->env_pgdir[i] = kern_pgdir[i];

p->pp_ref++;

e->env_pgdir[pdx(uvpt)] = paddr(e->env_pgdir) | pte_p | pte_u;

return 0;

}

static void region_alloc(struct env *e, void *va, size_t len)

{

uintptr_t addr = rounddown((uintptr_t)va, pgsize);

uintptr_t end = roundup((uintptr_t)va + len, pgsize);

while (addr < end) {

struct page *page = page_alloc(0);

if (page == null)

panic("region_alloc: not enough memory for page_alloc");

page_insert(e->env_pgdir, page, (void *)addr, pte_u | pte_w |

pte_p);

addr += pgsize;

}

}

static void load_icode(struct env *e, uint8_t *binary, size_t size)

{

struct elf *elfhdr = (struct elf *)binary;

if (elfhdr->e_magic != elf_magic)

panic("load_icode: bad elf");

struct proghdr *ph = (struct proghdr *) (binary + elfhdr->e_phoff);

universidad tecnica federico santa maria, departamento de informatica

83

b.3. lab 3: user environments

anexo b. desarrollo de curso ofrecido por mit

struct proghdr *eph = ph + elfhdr->e_phnum;

lcr3(paddr(e->env_pgdir));

for (; ph < eph; ph++) {

if (ph->p_type == elf_prog_load) {

if (ph->p_filesz > ph->p_memsz)

panic("load_icode: size in file should <= size in memory");

region_alloc(e, (void *)ph->p_va, ph->p_memsz);

memmove((void *)ph->p_va, binary + ph->p_offset, ph->p_filesz);

memset((void *)(ph->p_va + ph->p_filesz), 0,

ph->p_memsz - ph->p_filesz);

}

}

e->env_tf.tf_eip = elfhdr->e_entry;

region_alloc(e, (void *)(ustacktop - pgsize), pgsize);

}

void env_create(uint8_t *binary, enum envtype type)

{

}

struct env *e;

int code = env_alloc(&e, 0);

if (code < 0)

panic("error: cant create a new environment\n");

load_icode(e, binary);

e->env_link = null;

e->env_type = type;

void env_run(struct env *e)

{

if (curenv != e) {

if (curenv && curenv->env_status == env_running) {

universidad tecnica federico santa maria, departamento de informatica

84

b.3. lab 3: user environments

anexo b. desarrollo de curso ofrecido por mit

curenv->env_status = env_runnable;

}

curenv = e;

e->env_status = env_running;

e->env_runs++;

lcr3(paddr(e->env_pgdir));

}

env_pop_tf(&e->env_tf);

}

a este punto ya se puede ejecutar qemu para vericar las funciones ya ingresadas
en el proyecto. el laboratorio incluye un programa llamado hello que se puede ejecutar
como prueba. lo que nos presenta el problema de que no existen llamadas a sistemas que
controlen la ejecucion de este binario, lo que puede que se ejecute con muchos errores. es
importante a este punto vericar que todo esta corriendo donde corresponde, es decir, que
el almacenamiento de memoria realizado en el laboratorio 2 este funcionando bien, sino,
entonces este es el punto para volver a corregir el trabajo.

para el manejo de interrupciones y excepciones, se solicita realizar la lectura del capitulo
9 del manual del programador [21] o el capitulo 5 del manual de arquitectura de software
para el desarrollador intel[14].

la experiencia cuenta con cierta introduccion al tema de la utilizacion de una de las
formas en la cual el sistema operativo enfrenta las interrupciones, tales como la tabla
de descripcion de interrupciones y el segmento de procesos pendientes. se presenta un
ejemplo graco el cual se debe implementar de forma posterior modicando los archivos
kern/trapentry.s y kern/trap.c de tal forma de denirlas.

para el archivo kern/trapentry.s se debe agregar al nal del archivo las siguientes lineas:

traphandler_noec(div_zero, t_divide) /* 0 */

traphandler_noec(debug_exception, t_debug) /* 1 */

traphandler(non_mask_inter, t_nmi) /* 2 */

traphandler_noec(break_point, t_brkpt) /* 3 */

universidad tecnica federico santa maria, departamento de informatica

85

b.3. lab 3: user environments

anexo b. desarrollo de curso ofrecido por mit

traphandler_noec(overflow, t_oflow) /* 4 */

traphandler_noec(bounds_check, t_bound) /* 5 */

traphandler_noec(illegal_opcode, t_illop) /* 6 */

traphandler_noec(device_not_avail, t_device) /* 7 */

traphandler(double_fault, t_dblflt) /* 8 */

traphandler_noec(invalid_tss, t_tss) /* 10 */

traphandler(seg_not_pres, t_segnp) /* 11 */

traphandler(stack_exception, t_stack) /* 12 */

traphandler(gen_protec_fault, t_gpflt) /* 13 */

traphandler(page_fault, t_pgflt) /* 14 */

traphandler_noec(float_point_err, t_fperr) /* 16 */

traphandler_noec(align_check, t_align) /* 17 */

traphandler_noec(machine_check, t_mchk) /* 18 */

traphandler_noec(simd_float_error, t_simderr) /* 19 */

traphandler_noec(sys_call, t_syscall) /* 48 */

_alltraps:

pushl %ds

pushl %es

pushal

movw $gd_kd, %ax

movw %ax, %ds

movw %ax, %es

pushl %esp

call trap

y para el archivo kern/trap.c se debe modicar la funcion trap_init() para inicializar.

void trap_init(void)

universidad tecnica federico santa maria, departamento de informatica

86

b.3. lab 3: user environments

anexo b. desarrollo de curso ofrecido por mit

{

extern struct segdesc gdt[];

setgate(idt[t_divide], 0, gd_kt, div_zero, 0);

setgate(idt[t_debug], 0, gd_kt, debug_exception, 0);

setgate(idt[t_nmi], 0, gd_kt, non_mask_inter, 0);

setgate(idt[t_brkpt], 0, gd_kt, break_point, 3);

setgate(idt[t_oflow], 0, gd_kt, overflow, 0);

setgate(idt[t_bound], 0, gd_kt, bounds_check, 0);

setgate(idt[t_illop], 0, gd_kt, illegal_opcode, 0);

setgate(idt[t_device], 0, gd_kt, device_not_avail, 0);

setgate(idt[t_dblflt], 0, gd_kt, double_fault, 0);

setgate(idt[t_tss], 0, gd_kt, invalid_tss, 0);

setgate(idt[t_segnp], 0, gd_kt, seg_not_pres, 0);

setgate(idt[t_stack], 0, gd_kt, stack_exception, 0);

setgate(idt[t_gpflt], 0, gd_kt, gen_protec_fault, 0);

setgate(idt[t_pgflt], 0, gd_kt, page_fault, 0);

setgate(idt[t_fperr], 0, gd_kt, float_point_err, 0);

setgate(idt[t_align], 0, gd_kt, align_check, 0);

setgate(idt[t_mchk], 0, gd_kt, machine_check, 0);

setgate(idt[t_simderr], 0, gd_kt, simd_float_error, 0);

trap_init_percpu();

}

b.3.2. part b: page faults, breakpoints exceptions, and system calls

se solicita la modicacion de la funcion trap_dispatch() para despachar la pagina de
excepcion a la funcion page_fault_handler(). el objetivo es tener una excepcion en caso
de que la lista falle, esta se encuentra en la posicion 14 de la lista de vectores (t_pgflt).
ademas se pide enlazar, en la misma funcion, las interrupciones de tipo llamadas a sistema
(t_syscall) y modicar la funcion trap_init() y con ello modicar ademas la funcion
syscall() en el archivo kern/syscall.c. el codigo a modicar se encuentra en el archivo

universidad tecnica federico santa maria, departamento de informatica

87

b.3. lab 3: user environments

anexo b. desarrollo de curso ofrecido por mit

kern/trap.c y quedaria como:

static void trap_dispatch(struct trapframe *tf)

{

switch (tf->tf_trapno) {

case t_debug:

break;

case t_brkpt:

monitor(tf);

break;

case t_oflow:

break;

case t_syscall:

tf->tf_regs.reg_eax = syscall(tf->tf_regs.reg_eax,

tf->tf_regs.reg_edx, tf->tf_regs.reg_ecx, tf->tf_regs.reg_ebx,

tf->tf_regs.reg_edi, tf->tf_regs.reg_esi);

break;

case t_pgflt:

page_fault_handler(tf);

break;

default:

if (tf->tf_cs == gd_kt)

panic("unhandled trap in kernel");

else {

env_destroy(curenv);

return;

}

}

}

void page_fault_handler(struct trapframe *tf)

universidad tecnica federico santa maria, departamento de informatica

88

b.3. lab 3: user environments

anexo b. desarrollo de curso ofrecido por mit

{

}

uint32_t fault_va;

fault_va = rcr2();

if ((tf->tf_cs & 3) != 3)

panic("page fault happened in kernel mode\n");

cprintf("[%08x] user fault va %08x ip %08x\n",

curenv->env_id, fault_va, tf->tf_eip);

print_trapframe(tf);

env_destroy(curenv);

void trap_init(void)

{

extern struct segdesc gdt[];

setgate(idt[t_divide], 0, gd_kt, div_zero, 0);

setgate(idt[t_debug], 0, gd_kt, debug_exception, 0);

setgate(idt[t_nmi], 0, gd_kt, non_mask_inter, 0);

setgate(idt[t_brkpt], 0, gd_kt, break_point, 3);

setgate(idt[t_oflow], 0, gd_kt, overflow, 0);

setgate(idt[t_bound], 0, gd_kt, bounds_check, 0);

setgate(idt[t_illop], 0, gd_kt, illegal_opcode, 0);

setgate(idt[t_device], 0, gd_kt, device_not_avail, 0);

setgate(idt[t_dblflt], 0, gd_kt, double_fault, 0);

setgate(idt[t_tss], 0, gd_kt, invalid_tss, 0);

setgate(idt[t_segnp], 0, gd_kt, seg_not_pres, 0);

setgate(idt[t_stack], 0, gd_kt, stack_exception, 0);

setgate(idt[t_gpflt], 0, gd_kt, gen_protec_fault, 0);

setgate(idt[t_pgflt], 0, gd_kt, page_fault, 0);

setgate(idt[t_fperr], 0, gd_kt, float_point_err, 0);

setgate(idt[t_align], 0, gd_kt, align_check, 0);

setgate(idt[t_mchk], 0, gd_kt, machine_check, 0);

universidad tecnica federico santa maria, departamento de informatica

89

b.3. lab 3: user environments

anexo b. desarrollo de curso ofrecido por mit

setgate(idt[t_simderr], 0, gd_kt, simd_float_error, 0);

trap_init_percpu();

}

int32_t syscall(uint32_t syscallno, uint32_t a1, uint32_t a2,

uint32_t a3, uint32_t a4, uint32_t a5)

{

switch (syscallno) {

case sys_cputs:

sys_cputs((char *)a1, a2);

return 0;

case sys_cgetc:

return (int32_t)sys_cgetc();

case sys_getenvid:

return (int32_t)sys_getenvid();

case sys_env_destroy:

return sys_env_destroy(a1);

default:

return -e_inval;

}

}

a esta altura ya nos encontramos en una buena posicion para poder iniciar a nuestra
conveniencia el modo usuario. dicha instanciacion se realiza en la parte superior del archivo
lib/entry.s la que enlaza a la funcion libmain() que se encuentra en el archivo lib/libmain.c.
es necesario modicar esta funcion para que inicie el puntero global thisenv para que enlace
la estructira env en la lista envs[].

void libmain(int argc, char **argv)

{

thisenv = 0;

if (argc > 0)

universidad tecnica federico santa maria, departamento de informatica

90

b.3. lab 3: user environments

anexo b. desarrollo de curso ofrecido por mit

binaryname = argv[0];

envid_t thisenvid = sys_getenvid();

thisenv = &envs[envx(thisenvid)];

umain(argc, argv);

exit();

}

luego de ingresar este codigo, el sistema esta congurado para que inicie la aplicacion
user/hello la que nos saludara con un hello world y despues un i am environment
00001000.

para los fallos de paginas y la proteccion de la memoria, es importante tener una
forma en la cual los programas no utilicen la memoria de otros ya que puede ocasionar
problemas de procedimientos en ellos. en caso de que no haya memoria disponible, el
sistema operativo debe tratar de solucionar de alguna forma o lanzar una interrupcion al
respecto.

para el modo usuario es necesario realizar este tipo de revision en la memoria para que
el ambiente de trabajo funcione con la memoria correspondiente y no menos. para ello es
necesario editar el archivo kern/pmap.c y completar la funcion user_mem_check().

int user_mem_check(struct env *env, const void *va, size_t len,

int perm)

{

int permbits = perm | pte_p;

user_mem_check_addr = (uintptr_t)va;

for (uintptr_t i = rounddown((uint32_t)va, pgsize); i <

roundup((uint32_t)va + len, pgsize); i += pgsize) {

if (i >= ulim) {

if (user_mem_check_addr < i)

user_mem_check_addr = i;

return -e_fault;

}

universidad tecnica federico santa maria, departamento de informatica

91

b.4. lab 4: preemptive multitasking

anexo b. desarrollo de curso ofrecido por mit

pte_t *entry = pgdir_walk(env->env_pgdir, (void *)i, 0);

if (!entry) {

if (user_mem_check_addr < i)

user_mem_check_addr = i;

return -e_fault;

}

if ((*entry & permbits) != permbits) {

if (user_mem_check_addr < i)

user_mem_check_addr = i;

return -e_fault;

}

}

return 0;

}

luego es necesario modicar el arhicvo kern/syscall.c para revisar si los argumentos de
las llamadas a sistemas son correctas. finalmente editar el archivo kern/kdebug.c para que
en el usd, stabs y stabstr llame a la funcion user_mem_check().

finalmente basta con revisar que todo este corriendo como corresponde ejecutando
./grade-lab3. si es que hay alguna falta, es necesario revisar todo el procedimiento nueva-
mente.

b.4. lab 4: preemptive multitasking

al nalizar este laboratorio el sistema operativo contara con un sistema simple de
multitasking, lo que abre la posibilidad de contar con simultaneos ambientes de modo
usuario. en la parte a se trabajara sobre el sistema multiprocesos, implementando la
itineracion de tipo round-robin. en la parte b se trabajara en la implementacion de la funcion
fork() para realizar copias de procesos. en la parte c se trabajara en la comunicacion entre
procesos (ipc) con tal de que los procesos puedan trabajar en conjunto y sincronizados
entre los demas.

universidad tecnica federico santa maria, departamento de informatica

92

b.4. lab 4: preemptive multitasking

anexo b. desarrollo de curso ofrecido por mit

para comenzar es necesario copiar los nuevos archivos que se incluyen para esta

elaboracion.

git checkout -b lab4 origin/lab4

git merge lab3

el laboratorio esta separado por tres partes de las cuales es recomendable realizar una

por semana.

b.4.1. part a: multiprocessor support and cooperative multitasking

como se habia comentado anteriormente, en esta parte de la experiencia se trabaja en
correr un sistema que soporte multiprocesos y la implementacion de nuevas llamadas al
sistema que permita la creacion de nuevos procesos. tambien se implementa la itineracion
de tipo round-robin, permitiendo al kernel cambiar de un proceso a otro cuando el proceso
actual abandona voluntariamente la cpu.

para el soporte de multiprocesos se implementara el sistema smp (symmetric mul-
tiprocessing) que consiste en una particion equivalente de los recursos del hardware. el
codigo en este punto es separado en dos partes, los procesos de inicio del sistema (bsp) y
los procesos de aplicaciones (aps), en donde bsp activa las aps luego de que el sistema
operativo arranque.

lo primero que hay que realizar es la modicacion del archivo kern/pmap.c en la funcion
mmio_map_region; se debe realizar con lecturas previas al tema y buscando referencias en
la funcion lapic_init en el archivo kern/lapic.c. la funcion queda:

void * mmio_map_region(physaddr_t pa, size_t size)

{

static uintptr_t base = mmiobase;

uintptr_t retbase = base;

uintptr_t endaddr = roundup(base + size, pgsize);

if (endaddr >= mmiolim)

panic("too much size\n");

universidad tecnica federico santa maria, departamento de informatica

93

b.4. lab 4: preemptive multitasking

anexo b. desarrollo de curso ofrecido por mit

uint32_t mapped_size = roundup(size, pgsize);

boot_map_region(kern_pgdir, base, mapped_size, pa, pte_pcd |

pte_pwt | pte_w);

base += mapped_size;

return (void *)retbase;

}

antes de que comienze las aps, el bsp debe recolectar informacion del sistema, tal
como el numero total de cpu, sus ids del apic y las direcciones mmio de la unidad
lapic. la funcion mp_init() ubicada en el archivo kern/mpcong.c da esta informacion
leyendo la tabla que se ubica en la region de la memoria reservada para la bios.

luego se explica el uso de la funcion boot_aps() la cual, en resumen, recopila la
informacion antes nombrada e inicia las rutinas necesarias para que el sistema quede
como multiprocesos. con lo que como ejercicio se propone leer el comportamiento de
la funcion boot_aps() en detalle en conjunto de mp_main() en el archivo kern/init.c y el
codigo assembly kern/mpentry.s para luego modicar la funcion page_init() en kern/pmap.c
para evadir agregar la pagina mpentry_paddr a la lista libre. entonces nuestra funcion
quedaria cambiada como:

void page_init(void)

{

size_t i;

page_free_list = null;

for (i = 0; i < npages; i++) {

if (i == 0 || !inmapavail(&pages[i]) || isiniohole(&pages[i]) ||

page2pa(&pages[i]) == mpentry_paddr) {

pages[i].pp_ref = 1;

pages[i].pp_link = null;

} else {

pages[i].pp_ref = 0;

pages[i].pp_link = page_free_list;

universidad tecnica federico santa maria, departamento de informatica

94

b.4. lab 4: preemptive multitasking

anexo b. desarrollo de curso ofrecido por mit

page_free_list = &pages[i];

}

}

}

es importante distinguir entre los procesos que son per-cpu (privados entre ellos) y los
procesos globales que todo el sistema comparte. se solicita conocer el archivo kern/cpu.h
en donde se denen varios de los procesos per.cpu, incluyendo la estructura cpuinfo.
es necesario mapear en la pila per-cpu empezando en kstacktop, para ello hay que
modicar la funcion mem_init_mp() ubicada en kern/pmap.c.

static void mem_init_mp(void)

{

for (int i = 0; i < ncpu; i++) {

uintptr_t kstacktop_i = kstacktop - (i * (kstksize +

kstkgap));

boot_map_region(kern_pgdir, kstacktop_i - kstksize,

kstksize, paddr(percpu_kstacks[i]), pte_w | pte_p);

}

}

tambien es necesario modicar la funcion trap_init_percpu() ubicada en kern/trap.c ya

que se encuentra actualmente congurada para un solo proceso.

void trap_init_percpu(void)

{

int num = cpunum();

thiscpu->cpu_ts.ts_esp0 = kstacktop - num * (kstksize + kstkgap);

thiscpu->cpu_ts.ts_ss0 = gd_kd;

uint16_t index = (gd_tss0 >> 3) + num;

gdt[index] = seg16(sts_t32a, (uint32_t) (&thiscpu->cpu_ts),

sizeof(struct taskstate) - 1, 0);

universidad tecnica federico santa maria, departamento de informatica

95

b.4. lab 4: preemptive multitasking

anexo b. desarrollo de curso ofrecido por mit

gdt[index].sd_s = 0;

ltr(index << 3);

lidt(&idt_pd);

}

el sistema operativo debe contar con un sistema que proteja de conictos todo lo que
tenga que ver con procesos que corran a nivel del kernel, por lo que es importante contar
con algo que bloquee el acceso a los procesos que esten en modo usuario para que solo uno
se ejecute a la vez si es que necesita entrar a los niveles mas bajos. las deniciones para
este sistema se encuentran declaradas en kern/spinlock.h con la variable kernel_lock y las
funciones lock_kernel() y unlock_kernel().

es necesario implementar estas dos ultimas funciones en i386_init(), mp_main(), trap()

y env_run() segun corresponda.

void i386_init(uint32_t magic, uint32_t addr)

{

extern char edata[], end[];

memset(edata, 0, end - edata);

cons_init();

assert(magic == multiboot_bootloader_magic);

cprintf("451 decimal is %o octal!\n", 451);

cpuid_print();

e820_init(addr);

mem_init();

env_init();

trap_init();

acpi_init();

mp_init();

lapic_init();

pic_init();

ioapic_init();

universidad tecnica federico santa maria, departamento de informatica

96

b.4. lab 4: preemptive multitasking

anexo b. desarrollo de curso ofrecido por mit

ioapic_enable(irq_kbd, bootcpu->cpu_apicid);

ioapic_enable(irq_serial, bootcpu->cpu_apicid);

lock_kernel();

boot_aps();

#if defined(test)

env_create(test, env_type_user);

#else

env_create(user_yield, env_type_user);

#endif

sched_yield();

}

void mp_main(void)

{

}

lcr3(paddr(kern_pgdir));

cprintf("

ap #%d [apicid %02x] starting\n", cpunum(),

thiscpu->cpu_apicid);

lapic_init();

env_init_percpu();

trap_init_percpu();

xchg(&thiscpu->cpu_status, cpu_started);

lock_kernel();

sched_yield();

void trap(struct trapframe *tf)

{

asm volatile("cld" ::: "cc");

extern char *panicstr;

if (panicstr)

universidad tecnica federico santa maria, departamento de informatica

97

b.4. lab 4: preemptive multitasking

anexo b. desarrollo de curso ofrecido por mit

asm volatile("hlt");

if (xchg(&thiscpu->cpu_status, cpu_started) == cpu_halted)

lock_kernel();

assert(!(read_eflags() & fl_if));

if ((tf->tf_cs & 3) == 3) {

lock_kernel();

assert(curenv);

if (curenv->env_status == env_dying) {

env_free(curenv);

curenv = null;

sched_yield();

}

curenv->env_tf = *tf;

tf = &curenv->env_tf;

}

last_tf = tf;

trap_dispatch(tf);

if (curenv && curenv->env_status == env_running)

env_run(curenv);

else

sched_yield();

}

void env_run(struct env *e)

{

if (curenv != e) {

if (curenv && curenv->env_status == env_running) {

curenv->env_status = env_runnable;

}

curenv = e;

e->env_status = env_running;

universidad tecnica federico santa maria, departamento de informatica

98

b.4. lab 4: preemptive multitasking

anexo b. desarrollo de curso ofrecido por mit

e->env_runs++;

lcr3(paddr(e->env_pgdir));

}

unlock_kernel();

env_pop_tf(&e->env_tf);

}

ahora toca implementar el metodo round-robin para la itineracion de procesos en el
kernel. este funciona en base a la funcion sched_yield() en kern/sched.c la cual se encarga
de decidir cual es el siguiente proceso a considerar correr. es importante modicar dicha
funcion para la implementacion de este sistema y ademas cambiar syscall() para que utilice
sys_yield() la cual es la funcion que se utiliza a nivel usuario para llamar a sched_yield()
con seguridad.

void sched_yield(void)

{

}

struct env *idle;

idle = thiscpu->cpu_env;

int startenv = !idle ? 0 : envx(idle->env_id);

for (int i =

startenv; i < nenv + startenv; i++) {

if (envs[i % nenv].env_status == env_runnable) {

env_run(&envs[i % nenv]);

}

}

if (idle && idle->env_status == env_running) {

env_run(idle);

}

sched_halt();

es necesario actualizar la funcion mp_main de kern/init.c para que sea invocado

sched_yield(). desde este punto ya es posible ejecutar qemu con la variable cpus=1.

universidad tecnica federico santa maria, departamento de informatica

99

b.4. lab 4: preemptive multitasking

anexo b. desarrollo de curso ofrecido por mit

actualmente el sistema se encuentra limitado a correr procesos que el kernel inicial-
mente lista para ejecutar, por lo que ahora es necesario implementar llamadas a sistemas
necesarias para que el usuario pueda crear y comenzar un proceso.

tal como lo hace unix, existe una forma de clonar procesos con una funcion llamada
fork() con la unica diferencia que este retorna el pid del proceso hijo cuando es el proceso
padre y 0 cuando es el proceso hijo. con esto cada proceso tiene su propio espacio de
memoria para su trabajo. la idea es implementar algo similar implementando las funciones
sys_exofork, sys_env_set_status, sys_page_alloc, sys_page_map y sys_page_unmap en el
archivo kern/syscall.c con ayuda de otras funciones nombradas en el enunciado. el resultado
es el siguiente:

static envid_t sys_exofork(void)

{

}

struct env *e;

int code = env_alloc(&e, thiscpu->cpu_env->env_id);

if (code < 0)

return code;

e->env_status = env_not_runnable;

e->env_tf = thiscpu->cpu_env->env_tf;

e->env_tf.tf_regs.reg_eax = 0;

return e->env_id;

static int sys_env_set_status(envid_t envid, int status)

{

if (status != env_runnable && status != env_running)

return -e_inval;

struct env *e;

int code = envid2env(envid, &e, 1);

if (!e)

return -e_bad_env;

universidad tecnica federico santa maria, departamento de informatica

100

b.4. lab 4: preemptive multitasking

anexo b. desarrollo de curso ofrecido por mit

e->env_status = status;

return 0;

}

static int sys_page_alloc(envid_t envid, void *va, int perm)

{

uintptr_t virtaddr = (uintptr_t) va;

if (virtaddr >= utop || (virtaddr % pgsize) ||

(perm & ~pte_syscall) || (perm & (pte_u | pte_p))

!= (pte_u | pte_p))

return -e_inval;

struct env *e;

int code = envid2env(envid, &e, 1);

if (!e)

return -e_bad_env;

struct pageinfo *pp = page_alloc(alloc_zero);

if (!pp)

return -e_no_mem;

code = page_insert(e->env_pgdir, pp, va, perm);

if (code < 0) {

page_decref(pp);

return -e_no_mem;

}

return code;

}

static int sys_page_unmap(envid_t envid, void *va)

{

uintptr_t virtaddr = (uintptr_t)va;

if (virtaddr >= utop || (virtaddr % pgsize))

return -e_inval;

universidad tecnica federico santa maria, departamento de informatica

101

b.4. lab 4: preemptive multitasking

anexo b. desarrollo de curso ofrecido por mit

struct env *e;

int code = envid2env(envid, &e, 1);

if (!e)

return -e_bad_env;

page_remove(e->env_pgdir, va);

return 0;

}

static int sys_page_map(envid_t srcenvid, void *srcva,

envid_t dstenvid, void *dstva, int perm)

{

uintptr_t srcaddr = (uintptr_t) srcva, dstaddr = (uintptr_t) dstva;

if (srcaddr >= utop || (srcaddr % pgsize) || dstaddr >= utop

|| (dstaddr % pgsize) || (perm & ~pte_syscall) ||

(perm & (pte_u | pte_p)) != (pte_u | pte_p))

return -e_inval;

struct env *e_src, *e_dst;

int code = envid2env(srcenvid, &e_src, 1);

if (!e_src)

return -e_bad_env;

int dst_code = envid2env(dstenvid, &e_dst, 1);

if (!e_dst)

return -e_bad_env;

pte_t *entry_addr;

struct pageinfo *pp = page_lookup(e_src->env_pgdir, srcva,

&entry_addr);

if (!pp)

return -e_inval;

if ((perm & pte_w) && !(*entry_addr & pte_w))

return -e_inval;

code = page_insert(e_dst->env_pgdir, pp, dstva, perm);

universidad tecnica federico santa maria, departamento de informatica

102

b.4. lab 4: preemptive multitasking

anexo b. desarrollo de curso ofrecido por mit

return code;

}

b.4.2. part b: copy-on-write fork

fork() es implementado en este sistema de tal forma que copia toda la informacion
del las paginas de memoria del padre y las pone en el lugar en el cual se reservo para el
hijo, y luego se llama a la funcion exec() para que este se independice del padre lo que
se puede considerar un gasto de recurso ya que se pueden evaluar metodos tales como el
copy-on-write el que copia la memoria solo cuando el hijo necesite una modicacion en
este, para lo demas utilizan un sistema de memoria compartida. en esta parte del laboratorio
se busca que dicha optimizacion sea implementada.

lo primero es implementar un sistema para que el usuario pueda registrar la entrada
de un proceso con la llamada a sistema sys_env_set_pgfault_upcall que se encuentra en el
archivo kern/syscall.c.

static int sys_env_set_pgfault_upcall(envid_t envid, void *func)

{

}

struct env *e;

int code = envid2env(envid, &e, 1);

if (!e)

return -e_bad_env;

e->env_pgfault_upcall = func;

return 0;

ahora hay que implementar un sistema de pila especial para los procesos ejecutados
en el modo usuario, pila llamada user exception stack la cual mejora bastante el manejo
de memoria y ayuda a reparar casos como la reestructuracion de la memoria. para esto
es necesario modicar la funcion page_fault_ahndler() del archivo kern/trap.c para que
soporte dicho requerimiento. el resultado es:

universidad tecnica federico santa maria, departamento de informatica

103

b.4. lab 4: preemptive multitasking

anexo b. desarrollo de curso ofrecido por mit

void page_fault_handler(struct trapframe *tf)

{

uint32_t fault_va;

fault_va = rcr2();

if ((tf->tf_cs & 3) == 0)

panic("page fault happened in kernel mode\n");

if (curenv->env_pgfault_upcall) {

struct utrapframe *ttf;

uintptr_t esp, ebp;

if ((tf->tf_esp < uxstacktop && tf->tf_esp >= uxstacktop -

pgsize)) {

esp = (uintptr_t)(tf->tf_esp - 4 - sizeof(struct utrapframe));

ebp = (uint32_t)(tf->tf_esp - 4);

} else {

esp = (uintptr_t)(uxstacktop - sizeof(struct utrapframe));

ebp = (uintptr_t)(uxstacktop - 1);

}

user_mem_assert(curenv, (void *)esp, uxstacktop - esp,

pte_w | pte_u);

ttf = (struct utrapframe *)esp;

ttf->utf_fault_va = fault_va;

ttf->utf_err = tf->tf_err;

ttf->utf_regs = tf->tf_regs;

ttf->utf_eflags = tf->tf_eflags;

ttf->utf_esp = tf->tf_esp;

ttf->utf_eip = tf->tf_eip;

tf->tf_esp = esp;

tf->tf_regs.reg_ebp = ebp;

tf->tf_eip = (uint32_t)curenv->env_pgfault_upcall;

env_run(curenv);

universidad tecnica federico santa maria, departamento de informatica

104

b.4. lab 4: preemptive multitasking

anexo b. desarrollo de curso ofrecido por mit

}

cprintf("[%08x] user fault va %08x ip %08x\n",

curenv->env_id, fault_va, tf->tf_eip);

print_trapframe(tf);

env_destroy(curenv);

}

ahora es necesario implementar la rutina en assembly que permita la ejecucion del
manejo de paginas caidas en c y resuma la ejecucion en la ultima instruccion buena, por lo
que se debe modicar _pgfault_upcall en el archivo lib/pfentry.s

.text

.globl _pgfault_upcall

_pgfault_upcall:

pushl %esp

movl _pgfault_handler, %eax

call *%eax

addl $4, %esp

subl $4, 0x30(%esp)

addl $8, %esp

movl 0x28(%esp), %ebp

movl 0x20(%esp), %eax

movl %eax, (%ebp)

popal

addl $4, %esp

popfl

popl %esp

ret

luego, se necesita implementar la libreria c para el mecanismo de manejo de paginas,

por lo que se pide nalizar la funcion set_pgfault_handler() en el archivo lib/pgfault.c.

universidad tecnica federico santa maria, departamento de informatica

105

b.4. lab 4: preemptive multitasking

anexo b. desarrollo de curso ofrecido por mit

void set_pgfault_handler(void (*handler)(struct utrapframe *utf))

{

int r;

if (_pgfault_handler == 0) {

if (sys_page_alloc(0, (void *)(uxstacktop - pgsize), pte_p |

pte_u | pte_w) < 0)

panic("gg cant alloc exeption stack\n");

sys_env_set_pgfault_upcall(0, _pgfault_upcall);

}

_pgfault_handler = handler;

}

luego de todo esto recien es posible implementar el sistema copy-on-write para la
funcion fork(). se pide modicar la funcion fork() del archivo lib/fork.c en conjunto con las
funciones duppage() y pgfault().

envid_t fork(void)

{

envid_t envid;

uint8_t *addr;

int r;

set_pgfault_handler(&pgfault);

envid = sys_exofork();

if (envid < 0)

panic("sys_exofork: %e", envid);

if (envid == 0) {

thisenv = &envs[envx(sys_getenvid())];

set_pgfault_handler(&pgfault);

return 0;

}

for (addr = (uint8_t *)utext; addr < (uint8_t *)ustacktop;

universidad tecnica federico santa maria, departamento de informatica

106

b.4. lab 4: preemptive multitasking

anexo b. desarrollo de curso ofrecido por mit

addr += pgsize) {

pde_t *dir = (pde_t *)&uvpd[pdx(addr)];

pte_t *entry = (pte_t *)&uvpt[pgnum(addr)];

if ((*dir & pte_p) && (*entry & pte_p))

r = duppage(envid, pgnum(addr));

}

r = sys_page_alloc(envid, (void *)(addr + pgsize), pte_w |

pte_p | pte_u);

if (r < 0)

panic("exception stack %d\n", r);

if (sys_env_set_pgfault_upcall(envid,

thisenv->env_pgfault_upcall) < 0)

panic("cant set upcall\n");

if ((r = sys_env_set_status(envid, env_runnable)) < 0)

panic("sys_env_set_status: %e", r);

return envid;

}

static int duppage(envid_t envid, unsigned pn)

{

int r;

void *address = (void *)(pn * pgsize);

pte_t *entry = (pte_t *)&uvpt[pn];

bool copywrite = ((*entry & pte_w) == pte_w || (*entry & pte_cow)

== pte_cow);

int perm = pte_p | pte_u;

if (copywrite) {

if (sys_page_map(0, rounddown(address, pgsize), envid,

rounddown(address, pgsize), perm | pte_cow) < 0)

panic("cant update child mapping\n");

if (sys_page_map(0, rounddown(address, pgsize), 0,

universidad tecnica federico santa maria, departamento de informatica

107

b.4. lab 4: preemptive multitasking

anexo b. desarrollo de curso ofrecido por mit

rounddown(address, pgsize), perm | pte_cow) < 0)

panic("cant update parent mapping\n");

} else if (sys_page_map(0, rounddown(address, pgsize), envid,

rounddown(address, pgsize), perm) < 0) {

panic("cant map parent to child\n");

}

return 0;

}

static void pgfault(struct utrapframe *utf)

{

}

void *addr = (void *) utf->utf_fault_va;

uint32_t err = utf->utf_err;

int r;

pte_t *entry;

if ((err & fec_wr) != fec_wr)

panic("broked\n");

entry = (pte_t *)&uvpt[pgnum(addr)];

if ((*entry & pte_cow) != pte_cow)

panic("incorrect perm\n");

if (sys_page_alloc(0, (void *)pftemp, pte_w |

pte_p | pte_u) < 0)

panic("cant allocate a page at temp\n");

memmove(pftemp, rounddown(addr, pgsize), pgsize);

if (sys_page_map(0, pftemp, 0, rounddown(addr, pgsize), pte_w |

pte_p | pte_u) < 0)

panic("gggg\n");

if (sys_page_unmap(0, pftemp) < 0)

panic("cant remove page at temp location\n");

universidad tecnica federico santa maria, departamento de informatica

108

b.4. lab 4: preemptive multitasking

anexo b. desarrollo de curso ofrecido por mit

con esto naliza la parte b de la experiencia.

b.4.3. part c: preemptive multitasking and inter-process communi-

cation (ipc)

en la parte nal de esta experiencia se desea implementar un sistema que comunique

los procesos en ejecucion mediante envio de mensajes.

primero es necesario implementar un sistema de interrupcion que tenga directa relacion
con el clock, de tal forma que, por ejemplo, procesos que queden en loop innito puedan
ser nalizados despues de un transcurso de tiempo. para esto es necesario modicar la
funcion env_alloc en el archivo kern/env.c

int env_alloc(struct env **newenv_store, envid_t parent_id)

{

int32_t generation;

int r;

struct env *e;

if (!(e = env_free_list))

return -e_no_free_env;

if ((r = env_setup_vm(e)) < 0)

return r;

generation = (e->env_id + (1 << envgenshift)) & ~(nenv - 1);

if (generation <= 0)

// dont create a negative env_id.

generation = 1 << envgenshift;

e->env_id = generation | (e - envs);

e->env_parent_id = parent_id;

e->env_type = env_type_user;

e->env_status = env_runnable;

e->env_runs = 0;

memset(&e->env_tf, 0, sizeof(e->env_tf));

e->env_tf.tf_ds = gd_ud | 3;

universidad tecnica federico santa maria, departamento de informatica

109

b.4. lab 4: preemptive multitasking

anexo b. desarrollo de curso ofrecido por mit

e->env_tf.tf_es = gd_ud | 3;

e->env_tf.tf_ss = gd_ud | 3;

e->env_tf.tf_esp = ustacktop;

e->env_tf.tf_cs = gd_ut | 3;

e->env_tf.tf_eflags = fl_if;

e->env_pgfault_upcall = 0;

e->env_ipc_recving = 0;

env_free_list = e->env_link;

*newenv_store = e;

cprintf("[%08x] new env %08x\n", curenv ? curenv->env_id : 0,

e->env_id);

return 0;

}

ahora, para manejar estas interrupciones es necesario modicar la funcion con la cual
ya trabajamos antes llamada trap_dispatch() para que llame a sched_yield()para buscar y
correr un ambiente diferente cuando una interrupcion de tipo clock toma lugar.

static void trap_dispatch(struct trapframe *tf)

{

if (tf->tf_trapno == irq_offset + irq_spurious) {

cprintf("spurious interrupt on irq 7\n");

print_trapframe(tf);

return;

}

switch (tf->tf_trapno) {

case t_brkpt:

monitor(tf);

break;

case t_syscall:

tf->tf_regs.reg_eax = syscall(tf->tf_regs.reg_eax,

universidad tecnica federico santa maria, departamento de informatica

110

b.4. lab 4: preemptive multitasking

anexo b. desarrollo de curso ofrecido por mit

tf->tf_regs.reg_edx, tf->tf_regs.reg_ecx,

tf->tf_regs.reg_ebx, tf->tf_regs.reg_edi,

tf->tf_regs.reg_esi);

break;

case t_pgflt:

page_fault_handler(tf);

break;

case irq_offset + irq_timer:

lapic_eoi();

time_tick();

sched_yield();

break;

default:

print_trapframe(tf);

if (tf->tf_cs == gd_kt)

panic("unhandled trap in kernel");

else {

env_destroy(curenv);

return;

}

}

}

antes de proceder con lo importante de esta experiencia, es bueno saber si todo lo ya
programado se encuentra ejecutando en orden. por lo que es esencial que lo que se ha
modicado este pasando todos los test posibles y que no tenga inconsecuencias.

se comienza a trabajar con la implementacion de la comunicacion entre procesos (ipc).
primero es necesario construir dos llamadas a sistemas y dos paquetes de librerias, estas son
sys_ipc_recv(), sys_ipc_try_send(), ipc_recv y ipc_send respectivamente de los archivos
kern/syscall.c y lib/ipc.c.

universidad tecnica federico santa maria, departamento de informatica

111

b.4. lab 4: preemptive multitasking

anexo b. desarrollo de curso ofrecido por mit

static int sys_ipc_recv(void *dstva)

{

}

uintptr_t dst_va = (uintptr_t)dstva;

if (dst_va < utop && (dst_va % pgsize))

return -e_inval;

curenv->env_ipc_recving = 1;

curenv->env_ipc_dstva = dst_va < utop ?

dstva : (void *)utop;

curenv->env_status = env_not_runnable;

curenv->env_tf.tf_regs.reg_eax = 0;

sys_yield();

return 0;

static int sys_ipc_try_send(envid_t envid, uint32_t value,

void *srcva, unsigned perm)

{

uintptr_t va_src = (uintptr_t) srcva;

struct env *e;

int code = envid2env(envid, &e, 0);

if (!e)

return -e_bad_env;

if (!e->env_ipc_recving)

return -e_ipc_not_recv;

if (va_src < utop) {

if ((va_src % pgsize) || (perm & ~pte_syscall) ||

(perm & (pte_u | pte_p)) != (pte_u | pte_p))

return -e_inval;

pte_t *entry_addr;

struct pageinfo *pp = page_lookup(

thiscpu->cpu_env->env_pgdir, srcva, &entry_addr);

universidad tecnica federico santa maria, departamento de informatica

112

b.4. lab 4: preemptive multitasking

anexo b. desarrollo de curso ofrecido por mit

if (!entry_addr)

return -e_inval;

if ((perm & pte_w) && !(*entry_addr & pte_w))

return -e_inval;

if ((uintptr_t)e->env_ipc_dstva < utop &&

page_insert(e->env_pgdir, pp, e->env_ipc_dstva, perm))

return -e_no_mem;

}

e->env_ipc_perm = va_src < utop ? perm : 0;

e->env_ipc_recving = 0;

e->env_ipc_from = curenv->env_id;

e->env_ipc_value = value;

e->env_status = env_runnable;

return 0;

}

int32_t ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)

{

if (!pg)

pg = (void *)(utop + 1);

int val = sys_ipc_recv(pg);

if (val < 0) {

if (from_env_store)

*from_env_store = 0;

if (perm_store)

*perm_store = 0;

return val;

}

if (from_env_store)

*from_env_store = thisenv->env_ipc_from;

if (perm_store)

universidad tecnica federico santa maria, departamento de informatica

113

b.5. lab 5: file system, spawn and shell

anexo b. desarrollo de curso ofrecido por mit

*perm_store = thisenv->env_ipc_perm;

return thisenv->env_ipc_value;

}

void ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)

{

}

if (!pg)

pg = (void *)(utop + 1);

int sys_val;

while ((sys_val = sys_ipc_try_send(to_env, val, pg, perm))

== -e_ipc_not_recv)

sys_yield();

if (sys_val < 0)

panic("ipc_send got a non-err recv error");

es posible probar estas funciones ejecutando qemu y utilizando los binarios user/-
pingpong y user/primes. con estas cuatro funciones desarrolladas ya nos encontramos
con la nalizacion de la experiencia 4 por lo que se puede revisar que todo este en orden
ejecutando ./grade-lab4.

b.5. lab 5: file system, spawn and shell

en esta experiencia se trabaja en la libreria spawn la que se encarga de cargar y correr
ejecutables que se encuentran en disco, y se preparara una terminal que corra dentro de la
consola. para esto es necesario implementar un sistema de le system.

al igual que los anteriores, se cargaran nuevos archivos predenidos que sirven de guia

para el desarrollo del trabajo.

git checkout -b lab5 origin/lab5

git merge lab4

universidad tecnica federico santa maria, departamento de informatica

114

b.5. lab 5: file system, spawn and shell

anexo b. desarrollo de curso ofrecido por mit

para proseguir es necesario comentar la linea env_create(fs_fs) del archivo kern/i-
nit.c y la llamada a la funcion close_all() en el archivo lib/exit.c de forma temporal hasta
que sea necesario ya que puede causar errores de ejecucion al implementar las funciones
de fs/fs.c.

b.5.1. the file system

la idea es implementar un le system con las funciones basicas, tales como crear, leer,
escribir y borrar. nno contendra ningun sistema de permisos ni un manejo de archivos para
mas de un usuario a la vez, tampoco tendra enlaces simbolicos, registro de tiempos, entre
otras cosas.

lo primero es dar los privilegios de tipo i/o en la funcion env_create() en el archivo

kern/env.c. ojo que solo debe darse estos permisos a esta funcion y no a ninguna otra.

void env_create(uint8_t *binary, enum envtype type)

{

struct env *e;

int code = env_alloc(&e, 0);

if (code < 0)

panic("error: cant create a new environment\n");

load_icode(e, binary);

e->env_link = null;

e->env_status = env_runnable;

e->env_type = type;

if (type == env_type_fs) {

pte_t *entry = pgdir_walk(e->env_pgdir, (void *)ahci_va, 0);

*entry |= pte_u | pte_w | pte_p;

}

}

lo siguiente es implementar un buer cache para ayudar con la memoria virtual de
los procesos. se trabajara con un disco duro de tamano 3gb o menos por lo que el mapeo

universidad tecnica federico santa maria, departamento de informatica

115

b.5. lab 5: file system, spawn and shell

anexo b. desarrollo de curso ofrecido por mit

se tiene que armar desde 0x10000000 a 0xd0000000. se pide implementar las funciones
bc_pgfault() y ush_block() en fs/bc.c.

static void bc_pgfault(struct utrapframe *utf)

{

}

void *addr = (void *) utf->utf_fault_va;

uint32_t blockno = ((uint32_t)addr - diskmap) / blksize;

int r;

if (addr < (void*)diskmap || addr >= (void*)(diskmap + disksize))

panic("page fault in fs: eip %08x, va %08x, err %04x",

utf->utf_eip, addr, utf->utf_err);

if (super && blockno >= super->s_nblocks)

panic("reading non-existent block %08x\n", blockno);

addr = rounddown(addr, pgsize);

if ((r = sys_page_alloc(0, addr, pte_u | pte_w | pte_p)) < 0)

panic("gucked %e\n", r);

if ((r = ahci_read((blockno * blksects), addr, (pgsize /

sectsize))) < 0)

panic("cant read\n");

if ((r = sys_page_map(0, addr, 0, addr, uvpt[pgnum(addr)] &

pte_syscall)) < 0)

panic("in bc_pgfault, sys_page_map: %e", r);

if (bitmap && block_is_free(blockno))

panic("reading free block %08x\n", blockno);

void flush_block(void *addr)

{

uint32_t blockno = ((uint32_t)addr - diskmap) / blksize;

if (addr < (void*)diskmap || addr >= (void*)(diskmap + disksize))

panic("flush_block of bad va %08x", addr);

universidad tecnica federico santa maria, departamento de informatica

116

b.5. lab 5: file system, spawn and shell

anexo b. desarrollo de curso ofrecido por mit

addr = rounddown(addr, pgsize);

if (va_is_mapped(addr) && va_is_dirty(addr)) {

int r;

if ((r = ahci_write((blockno * blksects), addr, (pgsize /

sectsize))) < 0)

panic("cant write\n");

if ((r = sys_page_map(0, addr, 0, addr, uvpt[pgnum(addr)] &

pte_syscall)) < 0)

panic("in bc_pgfault, sys_page_map: %e", r);

}

}

ahora hay que congurar el bloque de bitmap. se solicita implementar la funcion

alloc_block() usando free_block como modelo en el archivo fs/fs.c

int alloc_block(void)

{

}

int blockno = 0;

while (blockno != super->s_nblocks && !block_is_free(blockno))

blockno++;

if (blockno != super->s_nblocks) {

bitmap[blockno / 32] &= ~(bit(blockno % 32));

flush_block(diskaddr(blockno));

return blockno;

}

return -e_no_disk;

hay que trabajar ahora en las funciones relacionadas con el manejo de los bloques,
es decir, la modicacion de los bloques que son apuntados por la lista de punteros que lo
enlazan. hay que realizar las funciones le_block_walk() y le_get_block().

universidad tecnica federico santa maria, departamento de informatica

117

b.5. lab 5: file system, spawn and shell

anexo b. desarrollo de curso ofrecido por mit

static int file_block_walk(struct file *f, uint32_t filebno,

uint32_t **ppdiskbno, bool alloc)

{

if (filebno < 0 || filebno >= (ndirect + nindirect))

return -e_inval;

if (filebno < ndirect) {

if (ppdiskbno) {

*ppdiskbno = &f->f_direct[filebno];

}

} else {

if (!f->f_indirect) {

if (!alloc)

return -e_not_found;

f->f_indirect = alloc_block();

if (f->f_indirect < 0)

return -e_no_disk;

memset(diskaddr(f->f_indirect), 0, blksize);

}

uint32_t *ind = (uint32_t *)diskaddr(f->f_indirect);

if (ppdiskbno)

*ppdiskbno = &ind[filebno - ndirect];

}

return 0;

}

int file_get_block(struct file *f, uint32_t filebno, char **blk)

{

if (filebno < 0 || filebno >= ndirect + nindirect)

return -e_inval;

uint32_t *blockno;

int ret = file_block_walk(f, filebno, &blockno, 1);

universidad tecnica federico santa maria, departamento de informatica

118

b.5. lab 5: file system, spawn and shell

anexo b. desarrollo de curso ofrecido por mit

if (ret < 0)

return ret;

if (!(*blockno)) {

*blockno = alloc_block();

if (*blockno < 0)

return -e_no_disk;

}

if (blk)

*blk = (char *)diskaddr(*blockno);

return 0;

}

a esta altura ya se encuentra implementada la funcionalidad, ahora hay que hacerla
accesible a otros procesos que quieran utilizar le system. el camino de lectura y escritura
de archivos sera una peticion entre procesos con lo implementado en el laboratorio 4. para
ello es necesario editar la funcion serve_read() ubicada en fs/serv.c.

int serve_read(envid_t envid, union fsipc *ipc)

{

struct fsreq_read *req = &ipc->read;

struct fsret_read *ret = &ipc->readret;

int r;

struct openfile *o;

if (debug)

cprintf("serve_read %08x %08x %08x\n", envid,

req->req_fileid, req->req_n);

if ((r = openfile_lookup(envid, req->req_fileid, &o)) < 0)

return r;

r = file_read(o->o_file, ret->ret_buf, req->req_n,

o->o_fd->fd_offset);

if (r < 0)

universidad tecnica federico santa maria, departamento de informatica

119

b.5. lab 5: file system, spawn and shell

anexo b. desarrollo de curso ofrecido por mit

return r;

int read = r;

if ((r = seek(fd2num(o->o_fd), o->o_fd->fd_offset + r)) < 0) {

return r;

}

return read;

}

siguiendo el ritmo, y con la idea de la funcion implementada recien, implementar

serve_write() en fs/serv.c y devle_write() en lib/le.c.

int serve_write(envid_t envid, struct fsreq_write *req)

{

int r;

struct openfile *o;

if (debug)

cprintf("serve_write %08x %08x %08x\n", envid,

req->req_fileid, req->req_n);

if ((r = openfile_lookup(envid, req->req_fileid, &o)) < 0)

return r;

r = file_write(o->o_file, req->req_buf, req->req_n,

o->o_fd->fd_offset);

if (r < 0)

return r;

int bwritten = r;

if ((r = seek(fd2num(o->o_fd), o->o_fd->fd_offset + r)) < 0)

return r;

return bwritten;

}

static ssize_t devfile_write(struct fd *fd, const void *buf,

size_t n)

universidad tecnica federico santa maria, departamento de informatica

120

b.5. lab 5: file system, spawn and shell

anexo b. desarrollo de curso ofrecido por mit

{

int r;

fsipcbuf.write.req_fileid = fd->fd_file.id;

fsipcbuf.write.req_n = n;

memmove(fsipcbuf.write.req_buf, buf, n);

if ((r = fsipc(fsreq_write, null)) < 0)

return r;

assert(r <= n);

return r;

}

b.5.2. spawning processes

la idea es crear un nuevo ambiente, cargar archivos del le system en el y comenzar a
correr los procesos como hijos. spawn funciona de forma similar a fork() y exec() pero con
la diferencia que los ejecuta al iniciar.

se pide implementar una nueva llamada al sistema sys_env_set_trapframe() para inicia-
lizar el estado de un nuevo ambiente, en el archivo kern/syscall.c y actualizar la funcion
syscall().

static int sys_env_set_trapframe(envid_t envid, struct trapframe *tf)

{

}

struct env *e;

int code = envid2env(envid, &e, 1);

if (!e)

return code;

e->env_tf = *tf;

return 0;

int32_t

syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3,

universidad tecnica federico santa maria, departamento de informatica

121

b.5. lab 5: file system, spawn and shell

anexo b. desarrollo de curso ofrecido por mit

uint32_t a4, uint32_t a5)

{

switch (syscallno) {

case sys_cputs:

sys_cputs((char *)a1, a2);

return 0;

case sys_cgetc:

return (int32_t)sys_cgetc();

case sys_getenvid:

return (int32_t)sys_getenvid();

case sys_env_destroy:

return sys_env_destroy(a1);

case sys_yield:

sched_yield();

return 0;

case sys_page_alloc:

return sys_page_alloc(a1, (void *)a2, a3);

case sys_page_map:

return sys_page_map(a1, (void *)a2, a3, (void *)a4, a5);

case sys_page_unmap:

return sys_page_unmap(a1, (void *)a2);

case sys_exofork:

return sys_exofork();

case sys_env_set_status:

return sys_env_set_status(a1, a2);

case sys_env_set_pgfault_upcall:

return sys_env_set_pgfault_upcall(a1, (void *)a2);

case sys_time_msec:

return sys_time_msec();

case sys_ipc_try_send:

universidad tecnica federico santa maria, departamento de informatica

122

b.5. lab 5: file system, spawn and shell

anexo b. desarrollo de curso ofrecido por mit

return sys_ipc_try_send(a1, a2, (void *)a3, a4);

case sys_ipc_recv:

return sys_ipc_recv((void *)a1);

case sys_env_set_trapframe:

return sys_env_set_trapframe(a1, (struct trapframe *)a2);

default:

return -e_inval;

}

}

nos queda compartir los estados de las librerias de fork y spawn, tales como la infor-
macion de los procesos y los archivos. hay que cambiar fork de tal forma que ocupe las
librerias operativas del sistema integradas en este proceso y asi utilice una interaccion entre
las librerias; fork deja de trabajar de forma copy-on-write para algo mas optimo.

se solicita cambiar duppage en el archivo lib/fork.c para que funcione de la forma recien

comentada. despues implementar copy_shared_pages en lib/spawn.c.

static int duppage(envid_t envid, unsigned pn)

{

void *address = (void *)(pn * pgsize);

pte_t *entry = (pte_t *)&uvpt[pn];

bool copywrite = ((*entry & pte_w) == pte_w ||

(*entry & pte_cow) == pte_cow);

bool isshared = ((*entry & pte_syscall) & pte_share)

== pte_share;

int perm = pte_p | pte_u;

if (copywrite && !isshared) {

if (sys_page_map(0, rounddown(address, pgsize), envid,

rounddown(address, pgsize), perm | pte_cow) < 0)

panic("cant update child mapping\n");

if (sys_page_map(0, rounddown(address, pgsize), 0,

universidad tecnica federico santa maria, departamento de informatica

123

b.5. lab 5: file system, spawn and shell

anexo b. desarrollo de curso ofrecido por mit

rounddown(address, pgsize), perm | pte_cow) < 0)

panic("cant update parent mapping\n");

} else {

if (sys_page_map(0, rounddown(address, pgsize), envid,

rounddown(address, pgsize), isshared ?

(*entry & pte_syscall) : perm) < 0)

panic("cant map parent to child\n");

}

return 0;

}

static int copy_shared_pages(envid_t child)

{

uint8_t *addr;

int r;

for (addr = (uint8_t *)utext; addr < (uint8_t *)ustacktop;

addr += pgsize) {

pde_t *dir = (pde_t *)&uvpd[pdx(addr)];

pte_t *entry = (pte_t *)&uvpt[pgnum(addr)];

if ((*dir & pte_p) && ((*entry & pte_p) &&

(*entry & pte_share) == pte_share))

if ((r = sys_page_map(0, addr, child, addr,

(*entry & pte_syscall))) < 0)

panic("cant copy page mapping in spawn\n");

}

return 0;

}

universidad tecnica federico santa maria, departamento de informatica

124

b.5. lab 5: file system, spawn and shell

anexo b. desarrollo de curso ofrecido por mit

b.5.3. the keyboard interface

es necesario reconocer el teclado si es que queremos tener nuestra propia consola. es
necesario modicar la funcion trap_dispatch para usar kbd_intr, localizada en el archi-
vo kern/trap.c para manejar la interrupcion irq_offset+irq_kbd y serial_intr para
manejar la interrupcion irq_offset+irq_serial.

static void trap_dispatch(struct trapframe *tf)

{

if (tf->tf_trapno == irq_offset + irq_spurious) {

cprintf("spurious interrupt on irq 7\n");

print_trapframe(tf);

return;

}

switch (tf->tf_trapno) {

case t_brkpt:

monitor(tf);

break;

case t_syscall:

tf->tf_regs.reg_eax = syscall(tf->tf_regs.reg_eax,

tf->tf_regs.reg_edx, tf->tf_regs.reg_ecx,

tf->tf_regs.reg_ebx, tf->tf_regs.reg_edi,

tf->tf_regs.reg_esi);

break;

case t_pgflt:

page_fault_handler(tf);

break;

case irq_offset + irq_timer:

lapic_eoi();

time_tick();

sched_yield();

universidad tecnica federico santa maria, departamento de informatica

125

b.5. lab 5: file system, spawn and shell

anexo b. desarrollo de curso ofrecido por mit

break;

case irq_offset + irq_kbd:

lapic_eoi();

kbd_intr();

break;

case irq_offset + irq_serial:

lapic_eoi();

serial_intr();

break;

default:

print_trapframe(tf);

if (tf->tf_cs == gd_kt)

panic("unhandled trap in kernel");

else {

env_destroy(curenv);

return;

}

}

}

b.5.4. the shell

a esta altura solo nos queda vericar que todo el trabajo realizado en esta y las
experiencias anteriores dio frutos. el codigo de una consola ya viene implementado, lo
podemos ejecutar con el comando make run-icode y como prueba podemos ejecutar los
comandos:

echo hello world | cat

cat lorem |cat

cat lorem |num

cat lorem |num |num |num |num |num

universidad tecnica federico santa maria, departamento de informatica

126

b.5. lab 5: file system, spawn and shell

anexo b. desarrollo de curso ofrecido por mit

lsfd

si todo funciona, entonces se naliza el trabajo.

universidad tecnica federico santa maria, departamento de informatica

127

